<h1 id="countingrefs">Reference Counting</h1> <p>The macros in this section are used for managing reference counts of Python objects.</p> <dl class="function"> <dt id="c.Py_INCREF">
<code>void Py_INCREF(PyObject *o)</code> </dt> <dd>
<p>Increment the reference count for object <em>o</em>. The object must not be <code>NULL</code>; if you aren’t sure that it isn’t <code>NULL</code>, use <a class="reference internal" href="#c.Py_XINCREF" title="Py_XINCREF"><code>Py_XINCREF()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.Py_XINCREF">
<code>void Py_XINCREF(PyObject *o)</code> </dt> <dd>
<p>Increment the reference count for object <em>o</em>. The object may be <code>NULL</code>, in which case the macro has no effect.</p> </dd>
</dl> <dl class="function"> <dt id="c.Py_DECREF">
<code>void Py_DECREF(PyObject *o)</code> </dt> <dd>
<p>Decrement the reference count for object <em>o</em>. The object must not be <code>NULL</code>; if you aren’t sure that it isn’t <code>NULL</code>, use <a class="reference internal" href="#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a>. If the reference count reaches zero, the object’s type’s deallocation function (which must not be <code>NULL</code>) is invoked.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The deallocation function can cause arbitrary Python code to be invoked (e.g. when a class instance with a <a class="reference internal" href="../reference/datamodel#object.__del__" title="object.__del__"><code>__del__()</code></a> method is deallocated). While exceptions in such code are not propagated, the executed code has free access to all Python global variables. This means that any object that is reachable from a global variable should be in a consistent state before <a class="reference internal" href="#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> is invoked. For example, code to delete an object from a list should copy a reference to the deleted object in a temporary variable, update the list data structure, and then call <a class="reference internal" href="#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> for the temporary variable.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.Py_XDECREF">
<code>void Py_XDECREF(PyObject *o)</code> </dt> <dd>
<p>Decrement the reference count for object <em>o</em>. The object may be <code>NULL</code>, in which case the macro has no effect; otherwise the effect is the same as for <a class="reference internal" href="#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a>, and the same warning applies.</p> </dd>
</dl> <dl class="function"> <dt id="c.Py_CLEAR">
<code>void Py_CLEAR(PyObject *o)</code> </dt> <dd>
<p>Decrement the reference count for object <em>o</em>. The object may be <code>NULL</code>, in which case the macro has no effect; otherwise the effect is the same as for <a class="reference internal" href="#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a>, except that the argument is also set to <code>NULL</code>. The warning for <a class="reference internal" href="#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> does not apply with respect to the object passed because the macro carefully uses a temporary variable and sets the argument to <code>NULL</code> before decrementing its reference count.</p> <p>It is a good idea to use this macro whenever decrementing the reference count of an object that might be traversed during garbage collection.</p> </dd>
</dl> <p>The following functions are for runtime dynamic embedding of Python: <code>Py_IncRef(PyObject *o)</code>, <code>Py_DecRef(PyObject *o)</code>. They are simply exported function versions of <a class="reference internal" href="#c.Py_XINCREF" title="Py_XINCREF"><code>Py_XINCREF()</code></a> and <a class="reference internal" href="#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a>, respectively.</p> <p>The following functions or macros are only for use within the interpreter core: <code>_Py_Dealloc()</code>, <code>_Py_ForgetReference()</code>, <code>_Py_NewReference()</code>, as well as the global variable <code>_Py_RefTotal</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/refcounting.html" class="_attribution-link">https://docs.python.org/3.8/c-api/refcounting.html</a>
  </p>
</div>
