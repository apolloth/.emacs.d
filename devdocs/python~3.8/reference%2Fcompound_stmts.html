<h1 id="compound"> Compound statements</h1> <p id="index-0">Compound statements contain (groups of) other statements; they affect or control the execution of those other statements in some way. In general, compound statements span multiple lines, although in simple incarnations a whole compound statement may be contained in one line.</p> <p>The <a class="reference internal" href="#if"><code>if</code></a>, <a class="reference internal" href="#while"><code>while</code></a> and <a class="reference internal" href="#for"><code>for</code></a> statements implement traditional control flow constructs. <a class="reference internal" href="#try"><code>try</code></a> specifies exception handlers and/or cleanup code for a group of statements, while the <a class="reference internal" href="#with"><code>with</code></a> statement allows the execution of initialization and finalization code around a block of code. Function and class definitions are also syntactically compound statements.</p> <p id="index-1">A compound statement consists of one or more ‘clauses.’ A clause consists of a header and a ‘suite.’ The clause headers of a particular compound statement are all at the same indentation level. Each clause header begins with a uniquely identifying keyword and ends with a colon. A suite is a group of statements controlled by a clause. A suite can be one or more semicolon-separated simple statements on the same line as the header, following the header’s colon, or it can be one or more indented statements on subsequent lines. Only the latter form of a suite can contain nested compound statements; the following is illegal, mostly because it wouldn’t be clear to which <a class="reference internal" href="#if"><code>if</code></a> clause a following <a class="reference internal" href="#else"><code>else</code></a> clause would belong:</p> <pre data-language="python">if test1: if test2: print(x)
</pre> <p>Also note that the semicolon binds tighter than the colon in this context, so that in the following example, either all or none of the <a class="reference internal" href="../library/functions#print" title="print"><code>print()</code></a> calls are executed:</p> <pre data-language="python">if x &lt; y &lt; z: print(x); print(y); print(z)
</pre> <p>Summarizing:</p> <pre>
<strong id="grammar-token-compound-stmt">compound_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-if-stmt">if_stmt</a>
                   | <a class="reference internal" href="#grammar-token-while-stmt">while_stmt</a>
                   | <a class="reference internal" href="#grammar-token-for-stmt">for_stmt</a>
                   | <a class="reference internal" href="#grammar-token-try-stmt">try_stmt</a>
                   | <a class="reference internal" href="#grammar-token-with-stmt">with_stmt</a>
                   | <a class="reference internal" href="#grammar-token-funcdef">funcdef</a>
                   | <a class="reference internal" href="#grammar-token-classdef">classdef</a>
                   | <a class="reference internal" href="#grammar-token-async-with-stmt">async_with_stmt</a>
                   | <a class="reference internal" href="#grammar-token-async-for-stmt">async_for_stmt</a>
                   | <a class="reference internal" href="#grammar-token-async-funcdef">async_funcdef</a>
<strong id="grammar-token-suite">suite        </strong> ::=  <a class="reference internal" href="#grammar-token-stmt-list">stmt_list</a> NEWLINE | NEWLINE INDENT <a class="reference internal" href="#grammar-token-statement">statement</a>+ DEDENT
<strong id="grammar-token-statement">statement    </strong> ::=  <a class="reference internal" href="#grammar-token-stmt-list">stmt_list</a> NEWLINE | <a class="reference internal" href="#grammar-token-compound-stmt">compound_stmt</a>
<strong id="grammar-token-stmt-list">stmt_list    </strong> ::=  <a class="reference internal" href="simple_stmts#grammar-token-simple-stmt">simple_stmt</a> (";" <a class="reference internal" href="simple_stmts#grammar-token-simple-stmt">simple_stmt</a>)* [";"]
</pre> <p id="index-2">Note that statements always end in a <code>NEWLINE</code> possibly followed by a <code>DEDENT</code>. Also note that optional continuation clauses always begin with a keyword that cannot start a statement, thus there are no ambiguities (the ‘dangling <a class="reference internal" href="#else"><code>else</code></a>’ problem is solved in Python by requiring nested <a class="reference internal" href="#if"><code>if</code></a> statements to be indented).</p> <p>The formatting of the grammar rules in the following sections places each clause on a separate line for clarity.</p> <section id="the-if-statement"> <h2 id="if">
<span class="section-number">8.1. </span>The <code>if</code> statement</h2> <p id="index-3">The <a class="reference internal" href="#if"><code>if</code></a> statement is used for conditional execution:</p> <pre>
<strong id="grammar-token-if-stmt">if_stmt</strong> ::=  "if" <a class="reference internal" href="expressions#grammar-token-assignment-expression">assignment_expression</a> ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
             ("elif" <a class="reference internal" href="expressions#grammar-token-assignment-expression">assignment_expression</a> ":" <a class="reference internal" href="#grammar-token-suite">suite</a>)*
             ["else" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>]
</pre> <p>It selects exactly one of the suites by evaluating the expressions one by one until one is found to be true (see section <a class="reference internal" href="expressions#booleans"><span class="std std-ref">Boolean operations</span></a> for the definition of true and false); then that suite is executed (and no other part of the <a class="reference internal" href="#if"><code>if</code></a> statement is executed or evaluated). If all expressions are false, the suite of the <a class="reference internal" href="#else"><code>else</code></a> clause, if present, is executed.</p> </section> <section id="the-while-statement"> <h2 id="while">
<span class="section-number">8.2. </span>The <code>while</code> statement</h2> <p id="index-4">The <a class="reference internal" href="#while"><code>while</code></a> statement is used for repeated execution as long as an expression is true:</p> <pre>
<strong id="grammar-token-while-stmt">while_stmt</strong> ::=  "while" <a class="reference internal" href="expressions#grammar-token-assignment-expression">assignment_expression</a> ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
                ["else" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>]
</pre> <p>This repeatedly tests the expression and, if it is true, executes the first suite; if the expression is false (which may be the first time it is tested) the suite of the <code>else</code> clause, if present, is executed and the loop terminates.</p> <p id="index-5">A <a class="reference internal" href="simple_stmts#break"><code>break</code></a> statement executed in the first suite terminates the loop without executing the <code>else</code> clause’s suite. A <a class="reference internal" href="simple_stmts#continue"><code>continue</code></a> statement executed in the first suite skips the rest of the suite and goes back to testing the expression.</p> </section> <section id="the-for-statement"> <h2 id="for">
<span class="section-number">8.3. </span>The <code>for</code> statement</h2> <p id="index-6">The <a class="reference internal" href="#for"><code>for</code></a> statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object:</p> <pre>
<strong id="grammar-token-for-stmt">for_stmt</strong> ::=  "for" <a class="reference internal" href="simple_stmts#grammar-token-target-list">target_list</a> "in" <a class="reference internal" href="expressions#grammar-token-expression-list">expression_list</a> ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
              ["else" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>]
</pre> <p>The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the <code>expression_list</code>. The suite is then executed once for each item provided by the iterator, in the order returned by the iterator. Each item in turn is assigned to the target list using the standard rules for assignments (see <a class="reference internal" href="simple_stmts#assignment"><span class="std std-ref">Assignment statements</span></a>), and then the suite is executed. When the items are exhausted (which is immediately when the sequence is empty or an iterator raises a <a class="reference internal" href="../library/exceptions#StopIteration" title="StopIteration"><code>StopIteration</code></a> exception), the suite in the <code>else</code> clause, if present, is executed, and the loop terminates.</p> <p id="index-7">A <a class="reference internal" href="simple_stmts#break"><code>break</code></a> statement executed in the first suite terminates the loop without executing the <code>else</code> clause’s suite. A <a class="reference internal" href="simple_stmts#continue"><code>continue</code></a> statement executed in the first suite skips the rest of the suite and continues with the next item, or with the <code>else</code> clause if there is no next item.</p> <p>The for-loop makes assignments to the variables in the target list. This overwrites all previous assignments to those variables including those made in the suite of the for-loop:</p> <pre data-language="python">for i in range(10):
    print(i)
    i = 5             # this will not affect the for-loop
                      # because i will be overwritten with the next
                      # index in the range
</pre> <p id="index-8">Names in the target list are not deleted when the loop is finished, but if the sequence is empty, they will not have been assigned to at all by the loop. Hint: the built-in function <a class="reference internal" href="../library/stdtypes#range" title="range"><code>range()</code></a> returns an iterator of integers suitable to emulate the effect of Pascal’s <code>for i := a to b do</code>; e.g., <code>list(range(3))</code> returns the list <code>[0, 1, 2]</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p id="index-9">There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, e.g. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,</p> <pre data-language="python">for x in a[:]:
    if x &lt; 0: a.remove(x)
</pre> </div> </section> <section id="the-try-statement"> <h2 id="try">
<span class="section-number">8.4. </span>The <code>try</code> statement</h2> <p id="index-10">The <a class="reference internal" href="#try"><code>try</code></a> statement specifies exception handlers and/or cleanup code for a group of statements:</p> <pre>
<strong id="grammar-token-try-stmt">try_stmt </strong> ::=  <a class="reference internal" href="#grammar-token-try1-stmt">try1_stmt</a> | <a class="reference internal" href="#grammar-token-try2-stmt">try2_stmt</a>
<strong id="grammar-token-try1-stmt">try1_stmt</strong> ::=  "try" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
               ("except" [<a class="reference internal" href="expressions#grammar-token-expression">expression</a> ["as" <a class="reference internal" href="lexical_analysis#grammar-token-identifier">identifier</a>]] ":" <a class="reference internal" href="#grammar-token-suite">suite</a>)+
               ["else" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>]
               ["finally" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>]
<strong id="grammar-token-try2-stmt">try2_stmt</strong> ::=  "try" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
               "finally" ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
</pre> <p>The <a class="reference internal" href="#except"><code>except</code></a> clause(s) specify one or more exception handlers. When no exception occurs in the <a class="reference internal" href="#try"><code>try</code></a> clause, no exception handler is executed. When an exception occurs in the <code>try</code> suite, a search for an exception handler is started. This search inspects the except clauses in turn until one is found that matches the exception. An expression-less except clause, if present, must be last; it matches any exception. For an except clause with an expression, that expression is evaluated, and the clause matches the exception if the resulting object is “compatible” with the exception. An object is compatible with an exception if it is the class or a base class of the exception object, or a tuple containing an item that is the class or a base class of the exception object.</p> <p>If no except clause matches the exception, the search for an exception handler continues in the surrounding code and on the invocation stack. <a class="footnote-reference brackets" href="#id4" id="id1">1</a></p> <p>If the evaluation of an expression in the header of an except clause raises an exception, the original search for a handler is canceled and a search starts for the new exception in the surrounding code and on the call stack (it is treated as if the entire <a class="reference internal" href="#try"><code>try</code></a> statement raised the exception).</p> <p id="index-11">When a matching except clause is found, the exception is assigned to the target specified after the <code>as</code> keyword in that except clause, if present, and the except clause’s suite is executed. All except clauses must have an executable block. When the end of this block is reached, execution continues normally after the entire try statement. (This means that if two nested handlers exist for the same exception, and the exception occurs in the try clause of the inner handler, the outer handler will not handle the exception.)</p> <p>When an exception has been assigned using <code>as target</code>, it is cleared at the end of the except clause. This is as if</p> <pre data-language="python">except E as N:
    foo
</pre> <p>was translated to</p> <pre data-language="python">except E as N:
    try:
        foo
    finally:
        del N
</pre> <p>This means the exception must be assigned to a different name to be able to refer to it after the except clause. Exceptions are cleared because with the traceback attached to them, they form a reference cycle with the stack frame, keeping all locals in that frame alive until the next garbage collection occurs.</p> <p id="index-12">Before an except clause’s suite is executed, details about the exception are stored in the <a class="reference internal" href="../library/sys#module-sys" title="sys: Access system-specific parameters and functions."><code>sys</code></a> module and can be accessed via <a class="reference internal" href="../library/sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>. <a class="reference internal" href="../library/sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a> returns a 3-tuple consisting of the exception class, the exception instance and a traceback object (see section <a class="reference internal" href="datamodel#types"><span class="std std-ref">The standard type hierarchy</span></a>) identifying the point in the program where the exception occurred. <a class="reference internal" href="../library/sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a> values are restored to their previous values (before the call) when returning from a function that handled an exception.</p> <p id="index-13">The optional <code>else</code> clause is executed if the control flow leaves the <a class="reference internal" href="#try"><code>try</code></a> suite, no exception was raised, and no <a class="reference internal" href="simple_stmts#return"><code>return</code></a>, <a class="reference internal" href="simple_stmts#continue"><code>continue</code></a>, or <a class="reference internal" href="simple_stmts#break"><code>break</code></a> statement was executed. Exceptions in the <code>else</code> clause are not handled by the preceding <a class="reference internal" href="#except"><code>except</code></a> clauses.</p> <p id="index-14">If <a class="reference internal" href="#finally"><code>finally</code></a> is present, it specifies a ‘cleanup’ handler. The <a class="reference internal" href="#try"><code>try</code></a> clause is executed, including any <a class="reference internal" href="#except"><code>except</code></a> and <code>else</code> clauses. If an exception occurs in any of the clauses and is not handled, the exception is temporarily saved. The <code>finally</code> clause is executed. If there is a saved exception it is re-raised at the end of the <code>finally</code> clause. If the <code>finally</code> clause raises another exception, the saved exception is set as the context of the new exception. If the <code>finally</code> clause executes a <a class="reference internal" href="simple_stmts#return"><code>return</code></a>, <a class="reference internal" href="simple_stmts#break"><code>break</code></a> or <a class="reference internal" href="simple_stmts#continue"><code>continue</code></a> statement, the saved exception is discarded:</p> <pre data-language="python">&gt;&gt;&gt; def f():
...     try:
...         1/0
...     finally:
...         return 42
...
&gt;&gt;&gt; f()
42
</pre> <p>The exception information is not available to the program during execution of the <a class="reference internal" href="#finally"><code>finally</code></a> clause.</p> <p id="index-15">When a <a class="reference internal" href="simple_stmts#return"><code>return</code></a>, <a class="reference internal" href="simple_stmts#break"><code>break</code></a> or <a class="reference internal" href="simple_stmts#continue"><code>continue</code></a> statement is executed in the <a class="reference internal" href="#try"><code>try</code></a> suite of a <code>try</code>…<code>finally</code> statement, the <a class="reference internal" href="#finally"><code>finally</code></a> clause is also executed ‘on the way out.’</p> <p>The return value of a function is determined by the last <a class="reference internal" href="simple_stmts#return"><code>return</code></a> statement executed. Since the <a class="reference internal" href="#finally"><code>finally</code></a> clause always executes, a <code>return</code> statement executed in the <code>finally</code> clause will always be the last one executed:</p> <pre data-language="python">&gt;&gt;&gt; def foo():
...     try:
...         return 'try'
...     finally:
...         return 'finally'
...
&gt;&gt;&gt; foo()
'finally'
</pre> <p>Additional information on exceptions can be found in section <a class="reference internal" href="executionmodel#exceptions"><span class="std std-ref">Exceptions</span></a>, and information on using the <a class="reference internal" href="simple_stmts#raise"><code>raise</code></a> statement to generate exceptions may be found in section <a class="reference internal" href="simple_stmts#raise"><span class="std std-ref">The raise statement</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Prior to Python 3.8, a <a class="reference internal" href="simple_stmts#continue"><code>continue</code></a> statement was illegal in the <a class="reference internal" href="#finally"><code>finally</code></a> clause due to a problem with the implementation.</p> </div> </section> <section id="the-with-statement"> <h2 id="with">
<span class="section-number">8.5. </span>The <code>with</code> statement</h2> <p id="index-16">The <a class="reference internal" href="#with"><code>with</code></a> statement is used to wrap the execution of a block with methods defined by a context manager (see section <a class="reference internal" href="datamodel#context-managers"><span class="std std-ref">With Statement Context Managers</span></a>). This allows common <a class="reference internal" href="#try"><code>try</code></a>…<a class="reference internal" href="#except"><code>except</code></a>…<a class="reference internal" href="#finally"><code>finally</code></a> usage patterns to be encapsulated for convenient reuse.</p> <pre>
<strong id="grammar-token-with-stmt">with_stmt</strong> ::=  "with" <a class="reference internal" href="#grammar-token-with-item">with_item</a> ("," <a class="reference internal" href="#grammar-token-with-item">with_item</a>)* ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
<strong id="grammar-token-with-item">with_item</strong> ::=  <a class="reference internal" href="expressions#grammar-token-expression">expression</a> ["as" <a class="reference internal" href="simple_stmts#grammar-token-target">target</a>]
</pre> <p>The execution of the <a class="reference internal" href="#with"><code>with</code></a> statement with one “item” proceeds as follows:</p> <ol class="arabic"> <li>The context expression (the expression given in the <a class="reference internal" href="#grammar-token-with-item"><code>with_item</code></a>) is evaluated to obtain a context manager.</li> <li>The context manager’s <a class="reference internal" href="datamodel#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> is loaded for later use.</li> <li>The context manager’s <a class="reference internal" href="datamodel#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> is loaded for later use.</li> <li>The context manager’s <a class="reference internal" href="datamodel#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> method is invoked.</li> <li>
<p>If a target was included in the <a class="reference internal" href="#with"><code>with</code></a> statement, the return value from <a class="reference internal" href="datamodel#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> is assigned to it.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#with"><code>with</code></a> statement guarantees that if the <a class="reference internal" href="datamodel#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> method returns without an error, then <a class="reference internal" href="datamodel#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> will always be called. Thus, if an error occurs during the assignment to the target list, it will be treated the same as an error occurring within the suite would be. See step 6 below.</p> </div> </li> <li>The suite is executed.</li> <li>
<p>The context manager’s <a class="reference internal" href="datamodel#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> method is invoked. If an exception caused the suite to be exited, its type, value, and traceback are passed as arguments to <a class="reference internal" href="datamodel#object.__exit__" title="object.__exit__"><code>__exit__()</code></a>. Otherwise, three <a class="reference internal" href="../library/constants#None" title="None"><code>None</code></a> arguments are supplied.</p> <p>If the suite was exited due to an exception, and the return value from the <a class="reference internal" href="datamodel#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> method was false, the exception is reraised. If the return value was true, the exception is suppressed, and execution continues with the statement following the <a class="reference internal" href="#with"><code>with</code></a> statement.</p> <p>If the suite was exited for any reason other than an exception, the return value from <a class="reference internal" href="datamodel#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> is ignored, and execution proceeds at the normal location for the kind of exit that was taken.</p> </li> </ol> <p>The following code:</p> <pre data-language="python">with EXPRESSION as TARGET:
    SUITE
</pre> <p>is semantically equivalent to:</p> <pre data-language="python">manager = (EXPRESSION)
enter = type(manager).__enter__
exit = type(manager).__exit__
value = enter(manager)
hit_except = False

try:
    TARGET = value
    SUITE
except:
    hit_except = True
    if not exit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        exit(manager, None, None, None)
</pre> <p>With more than one item, the context managers are processed as if multiple <a class="reference internal" href="#with"><code>with</code></a> statements were nested:</p> <pre data-language="python">with A() as a, B() as b:
    SUITE
</pre> <p>is semantically equivalent to:</p> <pre data-language="python">with A() as a:
    with B() as b:
        SUITE
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>Support for multiple context expressions.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343" id="index-17"><strong>PEP 343</strong></a> - The “with” statement</dt>
<dd>
<p>The specification, background, and examples for the Python <a class="reference internal" href="#with"><code>with</code></a> statement.</p> </dd> </dl> </div> </section> <section id="function-definitions"> <h2 id="index-18">
<span class="section-number">8.6. </span>Function definitions</h2> <p id="index-19">A function definition defines a user-defined function object (see section <a class="reference internal" href="datamodel#types"><span class="std std-ref">The standard type hierarchy</span></a>):</p> <pre>
<strong id="grammar-token-funcdef">funcdef                  </strong> ::=  [<a class="reference internal" href="#grammar-token-decorators">decorators</a>] "def" <a class="reference internal" href="#grammar-token-funcname">funcname</a> "(" [<a class="reference internal" href="#grammar-token-parameter-list">parameter_list</a>] ")"
                               ["-&gt;" <a class="reference internal" href="expressions#grammar-token-expression">expression</a>] ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
<strong id="grammar-token-decorators">decorators               </strong> ::=  <a class="reference internal" href="#grammar-token-decorator">decorator</a>+
<strong id="grammar-token-decorator">decorator                </strong> ::=  "@" <a class="reference internal" href="#grammar-token-dotted-name">dotted_name</a> ["(" [<a class="reference internal" href="expressions#grammar-token-argument-list">argument_list</a> [","]] ")"] NEWLINE
<strong id="grammar-token-dotted-name">dotted_name              </strong> ::=  <a class="reference internal" href="lexical_analysis#grammar-token-identifier">identifier</a> ("." <a class="reference internal" href="lexical_analysis#grammar-token-identifier">identifier</a>)*
<strong id="grammar-token-parameter-list">parameter_list           </strong> ::=  <a class="reference internal" href="#grammar-token-defparameter">defparameter</a> ("," <a class="reference internal" href="#grammar-token-defparameter">defparameter</a>)* "," "/" ["," [<a class="reference internal" href="#grammar-token-parameter-list-no-posonly">parameter_list_no_posonly</a>]]
                                 | <a class="reference internal" href="#grammar-token-parameter-list-no-posonly">parameter_list_no_posonly</a>
<strong id="grammar-token-parameter-list-no-posonly">parameter_list_no_posonly</strong> ::=  <a class="reference internal" href="#grammar-token-defparameter">defparameter</a> ("," <a class="reference internal" href="#grammar-token-defparameter">defparameter</a>)* ["," [<a class="reference internal" href="#grammar-token-parameter-list-starargs">parameter_list_starargs</a>]]
                               | <a class="reference internal" href="#grammar-token-parameter-list-starargs">parameter_list_starargs</a>
<strong id="grammar-token-parameter-list-starargs">parameter_list_starargs  </strong> ::=  "*" [<a class="reference internal" href="#grammar-token-parameter">parameter</a>] ("," <a class="reference internal" href="#grammar-token-defparameter">defparameter</a>)* ["," ["**" <a class="reference internal" href="#grammar-token-parameter">parameter</a> [","]]]
                               | "**" <a class="reference internal" href="#grammar-token-parameter">parameter</a> [","]
<strong id="grammar-token-parameter">parameter                </strong> ::=  <a class="reference internal" href="lexical_analysis#grammar-token-identifier">identifier</a> [":" <a class="reference internal" href="expressions#grammar-token-expression">expression</a>]
<strong id="grammar-token-defparameter">defparameter             </strong> ::=  <a class="reference internal" href="#grammar-token-parameter">parameter</a> ["=" <a class="reference internal" href="expressions#grammar-token-expression">expression</a>]
<strong id="grammar-token-funcname">funcname                 </strong> ::=  <a class="reference internal" href="lexical_analysis#grammar-token-identifier">identifier</a>
</pre> <p>A function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function). This function object contains a reference to the current global namespace as the global namespace to be used when the function is called.</p> <p>The function definition does not execute the function body; this gets executed only when the function is called. <a class="footnote-reference brackets" href="#id5" id="id2">2</a></p> <p id="index-20">A function definition may be wrapped by one or more <a class="reference internal" href="../glossary#term-decorator"><span class="xref std std-term">decorator</span></a> expressions. Decorator expressions are evaluated when the function is defined, in the scope that contains the function definition. The result must be a callable, which is invoked with the function object as the only argument. The returned value is bound to the function name instead of the function object. Multiple decorators are applied in nested fashion. For example, the following code</p> <pre data-language="python">@f1(arg)
@f2
def func(): pass
</pre> <p>is roughly equivalent to</p> <pre data-language="python">def func(): pass
func = f1(arg)(f2(func))
</pre> <p>except that the original function is not temporarily bound to the name <code>func</code>.</p> <p id="index-21">When one or more <a class="reference internal" href="../glossary#term-parameter"><span class="xref std std-term">parameters</span></a> have the form <em>parameter</em> <code>=</code> <em>expression</em>, the function is said to have “default parameter values.” For a parameter with a default value, the corresponding <a class="reference internal" href="../glossary#term-argument"><span class="xref std std-term">argument</span></a> may be omitted from a call, in which case the parameter’s default value is substituted. If a parameter has a default value, all following parameters up until the “<code>*</code>” must also have a default value — this is a syntactic restriction that is not expressed by the grammar.</p> <p><strong>Default parameter values are evaluated from left to right when the function definition is executed.</strong> This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use <code>None</code> as the default, and explicitly test for it in the body of the function, e.g.:</p> <pre data-language="python">def whats_on_the_telly(penguin=None):
    if penguin is None:
        penguin = []
    penguin.append("property of the zoo")
    return penguin
</pre> <p id="index-22">Function call semantics are described in more detail in section <a class="reference internal" href="expressions#calls"><span class="std std-ref">Calls</span></a>. A function call always assigns values to all parameters mentioned in the parameter list, either from positional arguments, from keyword arguments, or from default values. If the form “<code>*identifier</code>” is present, it is initialized to a tuple receiving any excess positional parameters, defaulting to the empty tuple. If the form “<code>**identifier</code>” is present, it is initialized to a new ordered mapping receiving any excess keyword arguments, defaulting to a new empty mapping of the same type. Parameters after “<code>*</code>” or “<code>*identifier</code>” are keyword-only parameters and may only be passed by keyword arguments. Parameters before “<code>/</code>” are positional-only parameters and may only be passed by positional arguments.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The <code>/</code> function parameter syntax may be used to indicate positional-only parameters. See <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0570" id="index-23"><strong>PEP 570</strong></a> for details.</p> </div> <p id="index-24">Parameters may have an <a class="reference internal" href="../glossary#term-function-annotation"><span class="xref std std-term">annotation</span></a> of the form “<code>: expression</code>” following the parameter name. Any parameter may have an annotation, even those of the form <code>*identifier</code> or <code>**identifier</code>. Functions may have “return” annotation of the form “<code>-&gt; expression</code>” after the parameter list. These annotations can be any valid Python expression. The presence of annotations does not change the semantics of a function. The annotation values are available as values of a dictionary keyed by the parameters’ names in the <code>__annotations__</code> attribute of the function object. If the <code>annotations</code> import from <a class="reference internal" href="../library/__future__#module-__future__" title="__future__: Future statement definitions"><code>__future__</code></a> is used, annotations are preserved as strings at runtime which enables postponed evaluation. Otherwise, they are evaluated when the function definition is executed. In this case annotations may be evaluated in a different order than they appear in the source code.</p> <p id="index-25">It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions. This uses lambda expressions, described in section <a class="reference internal" href="expressions#lambda"><span class="std std-ref">Lambdas</span></a>. Note that the lambda expression is merely a shorthand for a simplified function definition; a function defined in a “<a class="reference internal" href="#def"><code>def</code></a>” statement can be passed around or assigned to another name just like a function defined by a lambda expression. The “<code>def</code>” form is actually more powerful since it allows the execution of multiple statements and annotations.</p> <p><strong>Programmer’s note:</strong> Functions are first-class objects. A “<code>def</code>” statement executed inside a function definition defines a local function that can be returned or passed around. Free variables used in the nested function can access the local variables of the function containing the def. See section <a class="reference internal" href="executionmodel#naming"><span class="std std-ref">Naming and binding</span></a> for details.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-3107" id="index-26"><strong>PEP 3107</strong></a> - Function Annotations</dt>
<dd>
<p>The original specification for function annotations.</p> </dd> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484" id="index-27"><strong>PEP 484</strong></a> - Type Hints</dt>
<dd>
<p>Definition of a standard meaning for annotations: type hints.</p> </dd> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526" id="index-28"><strong>PEP 526</strong></a> - Syntax for Variable Annotations</dt>
<dd>
<p>Ability to type hint variable declarations, including class variables and instance variables</p> </dd> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0563" id="index-29"><strong>PEP 563</strong></a> - Postponed Evaluation of Annotations</dt>
<dd>
<p>Support for forward references within annotations by preserving annotations in a string form at runtime instead of eager evaluation.</p> </dd> </dl> </div> </section> <section id="class-definitions"> <h2 id="class">
<span class="section-number">8.7. </span>Class definitions</h2> <p id="index-30">A class definition defines a class object (see section <a class="reference internal" href="datamodel#types"><span class="std std-ref">The standard type hierarchy</span></a>):</p> <pre>
<strong id="grammar-token-classdef">classdef   </strong> ::=  [<a class="reference internal" href="#grammar-token-decorators">decorators</a>] "class" <a class="reference internal" href="#grammar-token-classname">classname</a> [<a class="reference internal" href="#grammar-token-inheritance">inheritance</a>] ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
<strong id="grammar-token-inheritance">inheritance</strong> ::=  "(" [<a class="reference internal" href="expressions#grammar-token-argument-list">argument_list</a>] ")"
<strong id="grammar-token-classname">classname  </strong> ::=  <a class="reference internal" href="lexical_analysis#grammar-token-identifier">identifier</a>
</pre> <p>A class definition is an executable statement. The inheritance list usually gives a list of base classes (see <a class="reference internal" href="datamodel#metaclasses"><span class="std std-ref">Metaclasses</span></a> for more advanced uses), so each item in the list should evaluate to a class object which allows subclassing. Classes without an inheritance list inherit, by default, from the base class <a class="reference internal" href="../library/functions#object" title="object"><code>object</code></a>; hence,</p> <pre data-language="python">class Foo:
    pass
</pre> <p>is equivalent to</p> <pre data-language="python">class Foo(object):
    pass
</pre> <p>The class’s suite is then executed in a new execution frame (see <a class="reference internal" href="executionmodel#naming"><span class="std std-ref">Naming and binding</span></a>), using a newly created local namespace and the original global namespace. (Usually, the suite contains mostly function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved. <a class="footnote-reference brackets" href="#id6" id="id3">3</a> A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary. The class name is bound to this class object in the original local namespace.</p> <p>The order in which attributes are defined in the class body is preserved in the new class’s <code>__dict__</code>. Note that this is reliable only right after the class is created and only for classes that were defined using the definition syntax.</p> <p>Class creation can be customized heavily using <a class="reference internal" href="datamodel#metaclasses"><span class="std std-ref">metaclasses</span></a>.</p> <p id="index-31">Classes can also be decorated: just like when decorating functions,</p> <pre data-language="python">@f1(arg)
@f2
class Foo: pass
</pre> <p>is roughly equivalent to</p> <pre data-language="python">class Foo: pass
Foo = f1(arg)(f2(Foo))
</pre> <p>The evaluation rules for the decorator expressions are the same as for function decorators. The result is then bound to the class name.</p> <p><strong>Programmer’s note:</strong> Variables defined in the class definition are class attributes; they are shared by instances. Instance attributes can be set in a method with <code>self.name = value</code>. Both class and instance attributes are accessible through the notation “<code>self.name</code>”, and an instance attribute hides a class attribute with the same name when accessed in this way. Class attributes can be used as defaults for instance attributes, but using mutable values there can lead to unexpected results. <a class="reference internal" href="datamodel#descriptors"><span class="std std-ref">Descriptors</span></a> can be used to create instance variables with different implementation details.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115" id="index-32"><strong>PEP 3115</strong></a> - Metaclasses in Python 3000</dt>
<dd>
<p>The proposal that changed the declaration of metaclasses to the current syntax, and the semantics for how classes with metaclasses are constructed.</p> </dd> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-3129" id="index-33"><strong>PEP 3129</strong></a> - Class Decorators</dt>
<dd>
<p>The proposal that added class decorators. Function and method decorators were introduced in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0318" id="index-34"><strong>PEP 318</strong></a>.</p> </dd> </dl> </div> </section> <section id="coroutines"> <h2 id="async">
<span class="section-number">8.8. </span>Coroutines</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> <section id="coroutine-function-definition"> <h3 id="index-35">
<span class="section-number">8.8.1. </span>Coroutine function definition</h3> <pre>
<strong id="grammar-token-async-funcdef">async_funcdef</strong> ::=  [<a class="reference internal" href="#grammar-token-decorators">decorators</a>] "async" "def" <a class="reference internal" href="#grammar-token-funcname">funcname</a> "(" [<a class="reference internal" href="#grammar-token-parameter-list">parameter_list</a>] ")"
                   ["-&gt;" <a class="reference internal" href="expressions#grammar-token-expression">expression</a>] ":" <a class="reference internal" href="#grammar-token-suite">suite</a>
</pre> <p id="index-36">Execution of Python coroutines can be suspended and resumed at many points (see <a class="reference internal" href="../glossary#term-coroutine"><span class="xref std std-term">coroutine</span></a>). Inside the body of a coroutine function, <code>await</code> and <code>async</code> identifiers become reserved keywords; <a class="reference internal" href="expressions#await"><code>await</code></a> expressions, <a class="reference internal" href="#async-for"><code>async for</code></a> and <a class="reference internal" href="#async-with"><code>async with</code></a> can only be used in coroutine function bodies.</p> <p>Functions defined with <code>async def</code> syntax are always coroutine functions, even if they do not contain <code>await</code> or <code>async</code> keywords.</p> <p>It is a <a class="reference internal" href="../library/exceptions#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> to use a <code>yield from</code> expression inside the body of a coroutine function.</p> <p>An example of a coroutine function:</p> <pre data-language="python">async def func(param1, param2):
    do_stuff()
    await some_coroutine()
</pre> </section> <section id="the-async-for-statement"> <h3 id="index-37">
<span class="section-number">8.8.2. </span>The <code>async for</code> statement</h3> <pre>
<strong id="grammar-token-async-for-stmt">async_for_stmt</strong> ::=  "async" <a class="reference internal" href="#grammar-token-for-stmt">for_stmt</a>
</pre> <p>An <a class="reference internal" href="../glossary#term-asynchronous-iterable"><span class="xref std std-term">asynchronous iterable</span></a> is able to call asynchronous code in its <em>iter</em> implementation, and <a class="reference internal" href="../glossary#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> can call asynchronous code in its <em>next</em> method.</p> <p>The <code>async for</code> statement allows convenient iteration over asynchronous iterators.</p> <p>The following code:</p> <pre data-language="python">async for TARGET in ITER:
    SUITE
else:
    SUITE2
</pre> <p>Is semantically equivalent to:</p> <pre data-language="python">iter = (ITER)
iter = type(iter).__aiter__(iter)
running = True

while running:
    try:
        TARGET = await type(iter).__anext__(iter)
    except StopAsyncIteration:
        running = False
    else:
        SUITE
else:
    SUITE2
</pre> <p>See also <a class="reference internal" href="datamodel#object.__aiter__" title="object.__aiter__"><code>__aiter__()</code></a> and <a class="reference internal" href="datamodel#object.__anext__" title="object.__anext__"><code>__anext__()</code></a> for details.</p> <p>It is a <a class="reference internal" href="../library/exceptions#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> to use an <code>async for</code> statement outside the body of a coroutine function.</p> </section> <section id="the-async-with-statement"> <h3 id="index-38">
<span class="section-number">8.8.3. </span>The <code>async with</code> statement</h3> <pre>
<strong id="grammar-token-async-with-stmt">async_with_stmt</strong> ::=  "async" <a class="reference internal" href="#grammar-token-with-stmt">with_stmt</a>
</pre> <p>An <a class="reference internal" href="../glossary#term-asynchronous-context-manager"><span class="xref std std-term">asynchronous context manager</span></a> is a <a class="reference internal" href="../glossary#term-context-manager"><span class="xref std std-term">context manager</span></a> that is able to suspend execution in its <em>enter</em> and <em>exit</em> methods.</p> <p>The following code:</p> <pre data-language="python">async with EXPRESSION as TARGET:
    SUITE
</pre> <p>is semantically equivalent to:</p> <pre data-language="python">manager = (EXPRESSION)
aexit = type(manager).__aexit__
aenter = type(manager).__aenter__
value = await aenter(manager)
hit_except = False

try:
    TARGET = value
    SUITE
except:
    hit_except = True
    if not await aexit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        await aexit(manager, None, None, None)
</pre> <p>See also <a class="reference internal" href="datamodel#object.__aenter__" title="object.__aenter__"><code>__aenter__()</code></a> and <a class="reference internal" href="datamodel#object.__aexit__" title="object.__aexit__"><code>__aexit__()</code></a> for details.</p> <p>It is a <a class="reference internal" href="../library/exceptions#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> to use an <code>async with</code> statement outside the body of a coroutine function.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" id="index-39"><strong>PEP 492</strong></a> - Coroutines with async and await syntax</dt>
<dd>
<p>The proposal that made coroutines a proper standalone concept in Python, and added supporting syntax.</p> </dd> </dl> </div> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id4">
<code>1</code> </dt> <dd>
<p>The exception is propagated to the invocation stack unless there is a <a class="reference internal" href="#finally"><code>finally</code></a> clause which happens to raise another exception. That new exception causes the old one to be lost.</p> </dd> <dt class="label" id="id5">
<code>2</code> </dt> <dd>
<p>A string literal appearing as the first statement in the function body is transformed into the function’s <code>__doc__</code> attribute and therefore the function’s <a class="reference internal" href="../glossary#term-docstring"><span class="xref std std-term">docstring</span></a>.</p> </dd> <dt class="label" id="id6">
<code>3</code> </dt> <dd>
<p>A string literal appearing as the first statement in the class body is transformed into the namespace’s <code>__doc__</code> item and therefore the class’s <a class="reference internal" href="../glossary#term-docstring"><span class="xref std std-term">docstring</span></a>.</p> </dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/reference/compound_stmts.html" class="_attribution-link">https://docs.python.org/3.8/reference/compound_stmts.html</a>
  </p>
</div>
