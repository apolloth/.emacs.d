<h1 id="supporting-cycle-detection">Supporting Cyclic Garbage Collection</h1> <p>Python’s support for detecting and collecting garbage which involves circular references requires support from object types which are “containers” for other objects which may also be containers. Types which do not store references to other objects, or which only store references to atomic types (such as numbers or strings), do not need to provide any explicit support for garbage collection.</p> <p>To create a container type, the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field of the type object must include the <a class="reference internal" href="typeobj#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> and provide an implementation of the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler. If instances of the type are mutable, a <a class="reference internal" href="typeobj#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> implementation must also be provided.</p> <dl class="data"> <dt>
<code>Py_TPFLAGS_HAVE_GC</code> </dt> <dd>
<p>Objects with a type with this flag set must conform with the rules documented here. For convenience these objects will be referred to as container objects.</p> </dd>
</dl> <p>Constructors for container types must conform to two rules:</p> <ol class="arabic simple"> <li>The memory for the object must be allocated using <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New()</code></a> or <a class="reference internal" href="#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code>PyObject_GC_NewVar()</code></a>.</li> <li>Once all the fields which may contain references to other containers are initialized, it must call <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code>PyObject_GC_Track()</code></a>.</li> </ol> <dl class="function"> <dt id="c.PyObject_GC_New">
<code>TYPE* PyObject_GC_New(TYPE, PyTypeObject *type)</code> </dt> <dd>
<p>Analogous to <a class="reference internal" href="allocation#c.PyObject_New" title="PyObject_New"><code>PyObject_New()</code></a> but for container objects with the <a class="reference internal" href="typeobj#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag set.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GC_NewVar">
<code>TYPE* PyObject_GC_NewVar(TYPE, PyTypeObject *type, Py_ssize_t size)</code> </dt> <dd>
<p>Analogous to <a class="reference internal" href="allocation#c.PyObject_NewVar" title="PyObject_NewVar"><code>PyObject_NewVar()</code></a> but for container objects with the <a class="reference internal" href="typeobj#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag set.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GC_Resize">
<code>TYPE* PyObject_GC_Resize(TYPE, PyVarObject *op, Py_ssize_t newsize)</code> </dt> <dd>
<p>Resize an object allocated by <a class="reference internal" href="allocation#c.PyObject_NewVar" title="PyObject_NewVar"><code>PyObject_NewVar()</code></a>. Returns the resized object or <code>NULL</code> on failure. <em>op</em> must not be tracked by the collector yet.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GC_Track">
<code>void PyObject_GC_Track(PyObject *op)</code> </dt> <dd>
<p>Adds the object <em>op</em> to the set of container objects tracked by the collector. The collector can run at unexpected times so objects must be valid while being tracked. This should be called once all the fields followed by the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler become valid, usually near the end of the constructor.</p> </dd>
</dl> <p>Similarly, the deallocator for the object must conform to a similar pair of rules:</p> <ol class="arabic simple"> <li>Before fields which refer to other containers are invalidated, <a class="reference internal" href="#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code>PyObject_GC_UnTrack()</code></a> must be called.</li> <li>The object’s memory must be deallocated using <a class="reference internal" href="#c.PyObject_GC_Del" title="PyObject_GC_Del"><code>PyObject_GC_Del()</code></a>.</li> </ol> <dl class="function"> <dt id="c.PyObject_GC_Del">
<code>void PyObject_GC_Del(void *op)</code> </dt> <dd>
<p>Releases memory allocated to an object using <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New()</code></a> or <a class="reference internal" href="#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code>PyObject_GC_NewVar()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GC_UnTrack">
<code>void PyObject_GC_UnTrack(void *op)</code> </dt> <dd>
<p>Remove the object <em>op</em> from the set of container objects tracked by the collector. Note that <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code>PyObject_GC_Track()</code></a> can be called again on this object to add it back to the set of tracked objects. The deallocator (<a class="reference internal" href="typeobj#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> handler) should call this for the object before any of the fields used by the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler become invalid.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The <code>_PyObject_GC_TRACK()</code> and <code>_PyObject_GC_UNTRACK()</code> macros have been removed from the public C API.</p> </div> <p>The <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler accepts a function parameter of this type:</p> <dl class="type"> <dt id="c.visitproc">
<code>int (*visitproc)(PyObject *object, void *arg)</code> </dt> <dd>
<p>Type of the visitor function passed to the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler. The function should be called with an object to traverse as <em>object</em> and the third parameter to the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler as <em>arg</em>. The Python core uses several visitor functions to implement cyclic garbage detection; it’s not expected that users will need to write their own visitor functions.</p> </dd>
</dl> <p>The <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler must have the following type:</p> <dl class="type"> <dt id="c.traverseproc">
<code>int (*traverseproc)(PyObject *self, visitproc visit, void *arg)</code> </dt> <dd>
<p>Traversal function for a container object. Implementations must call the <em>visit</em> function for each object directly contained by <em>self</em>, with the parameters to <em>visit</em> being the contained object and the <em>arg</em> value passed to the handler. The <em>visit</em> function must not be called with a <code>NULL</code> object argument. If <em>visit</em> returns a non-zero value that value should be returned immediately.</p> </dd>
</dl> <p>To simplify writing <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handlers, a <a class="reference internal" href="#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a> macro is provided. In order to use this macro, the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> implementation must name its arguments exactly <em>visit</em> and <em>arg</em>:</p> <dl class="function"> <dt id="c.Py_VISIT">
<code>void Py_VISIT(PyObject *o)</code> </dt> <dd>
<p>If <em>o</em> is not <code>NULL</code>, call the <em>visit</em> callback, with arguments <em>o</em> and <em>arg</em>. If <em>visit</em> returns a non-zero value, then return it. Using this macro, <a class="reference internal" href="typeobj#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handlers look like:</p> <pre data-language="c">static int
my_traverse(Noddy *self, visitproc visit, void *arg)
{
    Py_VISIT(self-&gt;foo);
    Py_VISIT(self-&gt;bar);
    return 0;
}
</pre> </dd>
</dl> <p>The <a class="reference internal" href="typeobj#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> handler must be of the <a class="reference internal" href="#c.inquiry" title="inquiry"><code>inquiry</code></a> type, or <code>NULL</code> if the object is immutable.</p> <dl class="type"> <dt id="c.inquiry">
<code>int (*inquiry)(PyObject *self)</code> </dt> <dd>
<p>Drop references that may have created reference cycles. Immutable objects do not have to define this method since they can never directly create reference cycles. Note that the object must still be valid after calling this method (don’t just call <a class="reference internal" href="refcounting#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> on a reference). The collector will call this method if it detects that this object is involved in a reference cycle.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/gcsupport.html" class="_attribution-link">https://docs.python.org/3.8/c-api/gcsupport.html</a>
  </p>
</div>
