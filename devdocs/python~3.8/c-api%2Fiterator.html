<h1 id="id1">Iterator Objects</h1> <p>Python provides two general-purpose iterator objects. The first, a sequence iterator, works with an arbitrary sequence supporting the <a class="reference internal" href="../reference/datamodel#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. The second works with a callable object and a sentinel value, calling the callable for each item in the sequence, and ending the iteration when the sentinel value is returned.</p> <dl class="var"> <dt id="c.PySeqIter_Type">
<code>PyTypeObject PySeqIter_Type</code> </dt> <dd>
<p>Type object for iterator objects returned by <a class="reference internal" href="#c.PySeqIter_New" title="PySeqIter_New"><code>PySeqIter_New()</code></a> and the one-argument form of the <a class="reference internal" href="../library/functions#iter" title="iter"><code>iter()</code></a> built-in function for built-in sequence types.</p> </dd>
</dl> <dl class="function"> <dt id="c.PySeqIter_Check">
<code>int PySeqIter_Check(op)</code> </dt> <dd>
<p>Return true if the type of <em>op</em> is <a class="reference internal" href="#c.PySeqIter_Type" title="PySeqIter_Type"><code>PySeqIter_Type</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PySeqIter_New">
<code>PyObject* PySeqIter_New(PyObject *seq)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return an iterator that works with a general sequence object, <em>seq</em>. The iteration ends when the sequence raises <a class="reference internal" href="../library/exceptions#IndexError" title="IndexError"><code>IndexError</code></a> for the subscripting operation.</p> </dd>
</dl> <dl class="var"> <dt id="c.PyCallIter_Type">
<code>PyTypeObject PyCallIter_Type</code> </dt> <dd>
<p>Type object for iterator objects returned by <a class="reference internal" href="#c.PyCallIter_New" title="PyCallIter_New"><code>PyCallIter_New()</code></a> and the two-argument form of the <a class="reference internal" href="../library/functions#iter" title="iter"><code>iter()</code></a> built-in function.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyCallIter_Check">
<code>int PyCallIter_Check(op)</code> </dt> <dd>
<p>Return true if the type of <em>op</em> is <a class="reference internal" href="#c.PyCallIter_Type" title="PyCallIter_Type"><code>PyCallIter_Type</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyCallIter_New">
<code>PyObject* PyCallIter_New(PyObject *callable, PyObject *sentinel)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new iterator. The first parameter, <em>callable</em>, can be any Python callable object that can be called with no parameters; each call to it should return the next item in the iteration. When <em>callable</em> returns a value equal to <em>sentinel</em>, the iteration will be terminated.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/iterator.html" class="_attribution-link">https://docs.python.org/3.8/c-api/iterator.html</a>
  </p>
</div>
