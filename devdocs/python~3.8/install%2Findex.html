<h1 id="install-index">Installing Python Modules (Legacy version)</h1> <dl class="field-list simple"> <dt class="field-odd">Author</dt> <dd class="field-odd">
<p>Greg Ward</p> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="../installing/index#installing-index"><span class="std std-ref">Installing Python Modules</span></a></dt>
<dd>
<p>The up to date module installation documentation. For regular Python usage, you almost certainly want that document rather than this one.</p> </dd> </dl> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This document is being retained solely until the <code>setuptools</code> documentation at <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html">https://setuptools.readthedocs.io/en/latest/setuptools.html</a> independently covers all of the relevant information currently included here.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This guide only covers the basic tools for building and distributing extensions that are provided as part of this version of Python. Third party tools offer easier to use and more secure alternatives. Refer to the <a class="reference external" href="https://packaging.python.org/guides/tool-recommendations/">quick recommendations section</a> in the Python Packaging User Guide for more information.</p> </div> <section id="introduction"> <h2 id="inst-intro">Introduction</h2> <p>In Python 2.0, the <code>distutils</code> API was first added to the standard library. This provided Linux distro maintainers with a standard way of converting Python projects into Linux distro packages, and system administrators with a standard way of installing them directly onto target systems.</p> <p>In the many years since Python 2.0 was released, tightly coupling the build system and package installer to the language runtime release cycle has turned out to be problematic, and it is now recommended that projects use the <code>pip</code> package installer and the <code>setuptools</code> build system, rather than using <code>distutils</code> directly.</p> <p>See <a class="reference internal" href="../installing/index#installing-index"><span class="std std-ref">Installing Python Modules</span></a> and <a class="reference internal" href="../distributing/index#distributing-index"><span class="std std-ref">Distributing Python Modules</span></a> for more details.</p> <p>This legacy documentation is being retained only until we’re confident that the <code>setuptools</code> documentation covers everything needed.</p> <section id="distutils-based-source-distributions"> <h3 id="inst-new-standard">Distutils based source distributions</h3> <p>If you download a module source distribution, you can tell pretty quickly if it was packaged and distributed in the standard way, i.e. using the Distutils. First, the distribution’s name and version number will be featured prominently in the name of the downloaded archive, e.g. <code>foo-1.0.tar.gz</code> or <code>widget-0.9.7.zip</code>. Next, the archive will unpack into a similarly-named directory: <code>foo-1.0</code> or <code>widget-0.9.7</code>. Additionally, the distribution will contain a setup script <code>setup.py</code>, and a file named <code>README.txt</code> or possibly just <code>README</code>, which should explain that building and installing the module distribution is a simple matter of running one command from a terminal:</p> <pre data-language="none">python setup.py install
</pre> <p>For Windows, this command should be run from a command prompt window (<span class="menuselection">Start ‣ Accessories</span>):</p> <pre data-language="none">setup.py install
</pre> <p>If all these things are true, then you already know how to build and install the modules you’ve just downloaded: Run the command above. Unless you need to install things in a non-standard way or customize the build process, you don’t really need this manual. Or rather, the above command is everything you need to get out of this manual.</p> </section> </section> <section id="standard-build-and-install"> <h2 id="inst-standard-install">Standard Build and Install</h2> <p>As described in section <a class="reference internal" href="#inst-new-standard"><span class="std std-ref">Distutils based source distributions</span></a>, building and installing a module distribution using the Distutils is usually one simple command to run from a terminal:</p> <pre data-language="none">python setup.py install
</pre> <section id="platform-variations"> <h3 id="inst-platform-variations">Platform variations</h3> <p>You should always run the setup command from the distribution root directory, i.e. the top-level subdirectory that the module source distribution unpacks into. For example, if you’ve just downloaded a module source distribution <code>foo-1.0.tar.gz</code> onto a Unix system, the normal thing to do is:</p> <pre data-language="none">gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
cd foo-1.0
python setup.py install
</pre> <p>On Windows, you’d probably download <code>foo-1.0.zip</code>. If you downloaded the archive file to <code>C:\Temp</code>, then it would unpack into <code>C:\Temp\foo-1.0</code>; you can use either an archive manipulator with a graphical user interface (such as WinZip) or a command-line tool (such as <strong class="program">unzip</strong> or <strong class="program">pkunzip</strong>) to unpack the archive. Then, open a command prompt window and run:</p> <pre data-language="none">cd c:\Temp\foo-1.0
python setup.py install
</pre> </section> <section id="splitting-the-job-up"> <h3 id="inst-splitting-up">Splitting the job up</h3> <p>Running <code>setup.py install</code> builds and installs all modules in one run. If you prefer to work incrementally—especially useful if you want to customize the build process, or if things are going wrong—you can use the setup script to do one thing at a time. This is particularly helpful when the build and install will be done by different users—for example, you might want to build a module distribution and hand it off to a system administrator for installation (or do it yourself, with super-user privileges).</p> <p>For example, you can build everything in one step, and then install everything in a second step, by invoking the setup script twice:</p> <pre data-language="none">python setup.py build
python setup.py install
</pre> <p>If you do this, you will notice that running the <strong class="command">install</strong> command first runs the <strong class="command">build</strong> command, which—in this case—quickly notices that it has nothing to do, since everything in the <code>build</code> directory is up-to-date.</p> <p>You may not need this ability to break things down often if all you do is install modules downloaded off the ‘net, but it’s very handy for more advanced tasks. If you get into distributing your own Python modules and extensions, you’ll run lots of individual Distutils commands on their own.</p> </section> <section id="how-building-works"> <h3 id="inst-how-build-works">How building works</h3> <p>As implied above, the <strong class="command">build</strong> command is responsible for putting the files to install into a <em>build directory</em>. By default, this is <code>build</code> under the distribution root; if you’re excessively concerned with speed, or want to keep the source tree pristine, you can change the build directory with the <code>--build-base</code> option. For example:</p> <pre data-language="none">python setup.py build --build-base=/path/to/pybuild/foo-1.0
</pre> <p>(Or you could do this permanently with a directive in your system or personal Distutils configuration file; see section <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils Configuration Files</span></a>.) Normally, this isn’t necessary.</p> <p>The default layout for the build tree is as follows:</p> <pre data-language="none">--- build/ --- lib/
or
--- build/ --- lib.&lt;plat&gt;/
               temp.&lt;plat&gt;/
</pre> <p>where <code>&lt;plat&gt;</code> expands to a brief description of the current OS/hardware platform and Python version. The first form, with just a <code>lib</code> directory, is used for “pure module distributions”—that is, module distributions that include only pure Python modules. If a module distribution contains any extensions (modules written in C/C++), then the second form, with two <code>&lt;plat&gt;</code> directories, is used. In that case, the <code>temp.<em>plat</em></code> directory holds temporary files generated by the compile/link process that don’t actually get installed. In either case, the <code>lib</code> (or <code>lib.<em>plat</em></code>) directory contains all Python modules (pure Python and extensions) that will be installed.</p> <p>In the future, more directories will be added to handle Python scripts, documentation, binary executables, and whatever else is needed to handle the job of installing Python modules and applications.</p> </section> <section id="how-installation-works"> <h3 id="inst-how-install-works">How installation works</h3> <p>After the <strong class="command">build</strong> command runs (whether you run it explicitly, or the <strong class="command">install</strong> command does it for you), the work of the <strong class="command">install</strong> command is relatively simple: all it has to do is copy everything under <code>build/lib</code> (or <code>build/lib.<em>plat</em></code>) to your chosen installation directory.</p> <p>If you don’t choose an installation directory—i.e., if you just run <code>setup.py
install</code>—then the <strong class="command">install</strong> command installs to the standard location for third-party Python modules. This location varies by platform and by how you built/installed Python itself. On Unix (and Mac OS X, which is also Unix-based), it also depends on whether the module distribution being installed is pure Python or contains extensions (“non-pure”):</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Platform</p></th> <th class="head"><p>Standard installation location</p></th> <th class="head"><p>Default value</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>Unix (pure)</p></td> <td><p><code><em>prefix</em>/lib/python<em>X.Y</em>/site-packages</code></p></td> <td><p><code>/usr/local/lib/python<em>X.Y</em>/site-packages</code></p></td> <td><p>(1)</p></td> </tr> <tr>
<td><p>Unix (non-pure)</p></td> <td><p><code><em>exec-prefix</em>/lib/python<em>X.Y</em>/site-packages</code></p></td> <td><p><code>/usr/local/lib/python<em>X.Y</em>/site-packages</code></p></td> <td><p>(1)</p></td> </tr> <tr>
<td><p>Windows</p></td> <td><p><code><em>prefix</em>\Lib\site-packages</code></p></td> <td><p><code>C:\Python<em>XY</em>\Lib\site-packages</code></p></td> <td><p>(2)</p></td> </tr>  </table> <p>Notes:</p> <ol class="arabic simple"> <li>Most Linux distributions include Python as a standard part of the system, so <code><em>prefix</em></code> and <code><em>exec-prefix</em></code> are usually both <code>/usr</code> on Linux. If you build Python yourself on Linux (or any Unix-like system), the default <code><em>prefix</em></code> and <code><em>exec-prefix</em></code> are <code>/usr/local</code>.</li> <li>The default installation directory on Windows was <code>C:\Program
Files\Python</code> under Python 1.6a1, 1.5.2, and earlier.</li> </ol> <p><code><em>prefix</em></code> and <code><em>exec-prefix</em></code> stand for the directories that Python is installed to, and where it finds its libraries at run-time. They are always the same under Windows, and very often the same under Unix and Mac OS X. You can find out what your Python installation uses for <code><em>prefix</em></code> and <code><em>exec-prefix</em></code> by running Python in interactive mode and typing a few simple commands. Under Unix, just type <code>python</code> at the shell prompt. Under Windows, choose <span class="menuselection">Start ‣ Programs ‣ Python X.Y ‣ Python (command line)</span>. Once the interpreter is started, you type Python code at the prompt. For example, on my Linux system, I type the three Python statements shown below, and get the output as shown, to find out my <code><em>prefix</em></code> and <code><em>exec-prefix</em></code>:</p> <pre data-language="pycon">Python 2.4 (#26, Aug  7 2004, 17:19:02)
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.prefix
'/usr'
&gt;&gt;&gt; sys.exec_prefix
'/usr'
</pre> <p>A few other placeholders are used in this document: <code><em>X.Y</em></code> stands for the version of Python, for example <code>3.2</code>; <code><em>abiflags</em></code> will be replaced by the value of <a class="reference internal" href="../library/sys#sys.abiflags" title="sys.abiflags"><code>sys.abiflags</code></a> or the empty string for platforms which don’t define ABI flags; <code><em>distname</em></code> will be replaced by the name of the module distribution being installed. Dots and capitalization are important in the paths; for example, a value that uses <code>python3.2</code> on UNIX will typically use <code>Python32</code> on Windows.</p> <p>If you don’t want to install modules to the standard location, or if you don’t have permission to write there, then you need to read about alternate installations in section <a class="reference internal" href="#inst-alt-install"><span class="std std-ref">Alternate Installation</span></a>. If you want to customize your installation directories more heavily, see section <a class="reference internal" href="#inst-custom-install"><span class="std std-ref">Custom Installation</span></a> on custom installations.</p> </section> </section> <section id="alternate-installation"> <h2 id="inst-alt-install">Alternate Installation</h2> <p>Often, it is necessary or desirable to install modules to a location other than the standard location for third-party Python modules. For example, on a Unix system you might not have permission to write to the standard third-party module directory. Or you might wish to try out a module before making it a standard part of your local Python installation. This is especially true when upgrading a distribution already present: you want to make sure your existing base of scripts still works with the new version before actually upgrading.</p> <p>The Distutils <strong class="command">install</strong> command is designed to make installing module distributions to an alternate location simple and painless. The basic idea is that you supply a base directory for the installation, and the <strong class="command">install</strong> command picks a set of directories (called an <em>installation scheme</em>) under this base directory in which to install files. The details differ across platforms, so read whichever of the following sections applies to you.</p> <p>Note that the various alternate installation schemes are mutually exclusive: you can pass <code>--user</code>, or <code>--home</code>, or <code>--prefix</code> and <code>--exec-prefix</code>, or <code>--install-base</code> and <code>--install-platbase</code>, but you can’t mix from these groups.</p> <section id="alternate-installation-the-user-scheme"> <h3 id="inst-alt-install-user">Alternate installation: the user scheme</h3> <p>This scheme is designed to be the most convenient solution for users that don’t have write permission to the global site-packages directory or don’t want to install into it. It is enabled with a simple option:</p> <pre data-language="none">python setup.py install --user
</pre> <p>Files will be installed into subdirectories of <a class="reference internal" href="../library/site#site.USER_BASE" title="site.USER_BASE"><code>site.USER_BASE</code></a> (written as <code><em>userbase</em></code> hereafter). This scheme installs pure Python modules and extension modules in the same location (also known as <a class="reference internal" href="../library/site#site.USER_SITE" title="site.USER_SITE"><code>site.USER_SITE</code></a>). Here are the values for UNIX, including Mac OS X:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Installation directory</p></th> </tr> </thead>  <tr>
<td><p>modules</p></td> <td><p><code><em>userbase</em>/lib/python<em>X.Y</em>/site-packages</code></p></td> </tr> <tr>
<td><p>scripts</p></td> <td><p><code><em>userbase</em>/bin</code></p></td> </tr> <tr>
<td><p>data</p></td> <td><p><code><em>userbase</em></code></p></td> </tr> <tr>
<td><p>C headers</p></td> <td><p><code><em>userbase</em>/include/python<em>X.Y</em><em>abiflags</em>/<em>distname</em></code></p></td> </tr>  </table> <p>And here are the values used on Windows:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Installation directory</p></th> </tr> </thead>  <tr>
<td><p>modules</p></td> <td><p><code><em>userbase</em>\Python<em>XY</em>\site-packages</code></p></td> </tr> <tr>
<td><p>scripts</p></td> <td><p><code><em>userbase</em>\Python<em>XY</em>\Scripts</code></p></td> </tr> <tr>
<td><p>data</p></td> <td><p><code><em>userbase</em></code></p></td> </tr> <tr>
<td><p>C headers</p></td> <td><p><code><em>userbase</em>\Python<em>XY</em>\Include{distname}</code></p></td> </tr>  </table> <p>The advantage of using this scheme compared to the other ones described below is that the user site-packages directory is under normal conditions always included in <a class="reference internal" href="../library/sys#sys.path" title="sys.path"><code>sys.path</code></a> (see <a class="reference internal" href="../library/site#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> for more information), which means that there is no additional step to perform after running the <code>setup.py</code> script to finalize the installation.</p> <p>The <strong class="command">build_ext</strong> command also has a <code>--user</code> option to add <code><em>userbase</em>/include</code> to the compiler search path for header files and <code><em>userbase</em>/lib</code> to the compiler search path for libraries as well as to the runtime search path for shared C libraries (rpath).</p> </section> <section id="alternate-installation-the-home-scheme"> <h3 id="inst-alt-install-home">Alternate installation: the home scheme</h3> <p>The idea behind the “home scheme” is that you build and maintain a personal stash of Python modules. This scheme’s name is derived from the idea of a “home” directory on Unix, since it’s not unusual for a Unix user to make their home directory have a layout similar to <code>/usr/</code> or <code>/usr/local/</code>. This scheme can be used by anyone, regardless of the operating system they are installing for.</p> <p>Installing a new module distribution is as simple as</p> <pre data-language="none">python setup.py install --home=&lt;dir&gt;
</pre> <p>where you can supply any directory you like for the <code>--home</code> option. On Unix, lazy typists can just type a tilde (<code>~</code>); the <strong class="command">install</strong> command will expand this to your home directory:</p> <pre data-language="none">python setup.py install --home=~
</pre> <p>To make Python find the distributions installed with this scheme, you may have to <a class="reference internal" href="#inst-search-path"><span class="std std-ref">modify Python’s search path</span></a> or edit <code>sitecustomize</code> (see <a class="reference internal" href="../library/site#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a>) to call <a class="reference internal" href="../library/site#site.addsitedir" title="site.addsitedir"><code>site.addsitedir()</code></a> or edit <a class="reference internal" href="../library/sys#sys.path" title="sys.path"><code>sys.path</code></a>.</p> <p>The <code>--home</code> option defines the installation base directory. Files are installed to the following directories under the installation base as follows:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Installation directory</p></th> </tr> </thead>  <tr>
<td><p>modules</p></td> <td><p><code><em>home</em>/lib/python</code></p></td> </tr> <tr>
<td><p>scripts</p></td> <td><p><code><em>home</em>/bin</code></p></td> </tr> <tr>
<td><p>data</p></td> <td><p><code><em>home</em></code></p></td> </tr> <tr>
<td><p>C headers</p></td> <td><p><code><em>home</em>/include/python/<em>distname</em></code></p></td> </tr>  </table> <p>(Mentally replace slashes with backslashes if you’re on Windows.)</p> </section> <section id="alternate-installation-unix-the-prefix-scheme"> <h3 id="inst-alt-install-prefix-unix">Alternate installation: Unix (the prefix scheme)</h3> <p>The “prefix scheme” is useful when you wish to use one Python installation to perform the build/install (i.e., to run the setup script), but install modules into the third-party module directory of a different Python installation (or something that looks like a different Python installation). If this sounds a trifle unusual, it is—that’s why the user and home schemes come before. However, there are at least two known cases where the prefix scheme will be useful.</p> <p>First, consider that many Linux distributions put Python in <code>/usr</code>, rather than the more traditional <code>/usr/local</code>. This is entirely appropriate, since in those cases Python is part of “the system” rather than a local add-on. However, if you are installing Python modules from source, you probably want them to go in <code>/usr/local/lib/python2.<em>X</em></code> rather than <code>/usr/lib/python2.<em>X</em></code>. This can be done with</p> <pre data-language="none">/usr/bin/python setup.py install --prefix=/usr/local
</pre> <p>Another possibility is a network filesystem where the name used to write to a remote directory is different from the name used to read it: for example, the Python interpreter accessed as <code>/usr/local/bin/python</code> might search for modules in <code>/usr/local/lib/python2.<em>X</em></code>, but those modules would have to be installed to, say, <code>/mnt/<em>@server</em>/export/lib/python2.<em>X</em></code>. This could be done with</p> <pre data-language="none">/usr/local/bin/python setup.py install --prefix=/mnt/@server/export
</pre> <p>In either case, the <code>--prefix</code> option defines the installation base, and the <code>--exec-prefix</code> option defines the platform-specific installation base, which is used for platform-specific files. (Currently, this just means non-pure module distributions, but could be expanded to C libraries, binary executables, etc.) If <code>--exec-prefix</code> is not supplied, it defaults to <code>--prefix</code>. Files are installed as follows:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Installation directory</p></th> </tr> </thead>  <tr>
<td><p>Python modules</p></td> <td><p><code><em>prefix</em>/lib/python<em>X.Y</em>/site-packages</code></p></td> </tr> <tr>
<td><p>extension modules</p></td> <td><p><code><em>exec-prefix</em>/lib/python<em>X.Y</em>/site-packages</code></p></td> </tr> <tr>
<td><p>scripts</p></td> <td><p><code><em>prefix</em>/bin</code></p></td> </tr> <tr>
<td><p>data</p></td> <td><p><code><em>prefix</em></code></p></td> </tr> <tr>
<td><p>C headers</p></td> <td><p><code><em>prefix</em>/include/python<em>X.Y</em><em>abiflags</em>/<em>distname</em></code></p></td> </tr>  </table> <p>There is no requirement that <code>--prefix</code> or <code>--exec-prefix</code> actually point to an alternate Python installation; if the directories listed above do not already exist, they are created at installation time.</p> <p>Incidentally, the real reason the prefix scheme is important is simply that a standard Unix installation uses the prefix scheme, but with <code>--prefix</code> and <code>--exec-prefix</code> supplied by Python itself as <code>sys.prefix</code> and <code>sys.exec_prefix</code>. Thus, you might think you’ll never use the prefix scheme, but every time you run <code>python setup.py install</code> without any other options, you’re using it.</p> <p>Note that installing extensions to an alternate Python installation has no effect on how those extensions are built: in particular, the Python header files (<code>Python.h</code> and friends) installed with the Python interpreter used to run the setup script will be used in compiling extensions. It is your responsibility to ensure that the interpreter used to run extensions installed in this way is compatible with the interpreter used to build them. The best way to do this is to ensure that the two interpreters are the same version of Python (possibly different builds, or possibly copies of the same build). (Of course, if your <code>--prefix</code> and <code>--exec-prefix</code> don’t even point to an alternate Python installation, this is immaterial.)</p> </section> <section id="alternate-installation-windows-the-prefix-scheme"> <h3 id="inst-alt-install-prefix-windows">Alternate installation: Windows (the prefix scheme)</h3> <p>Windows has no concept of a user’s home directory, and since the standard Python installation under Windows is simpler than under Unix, the <code>--prefix</code> option has traditionally been used to install additional packages in separate locations on Windows.</p> <pre data-language="none">python setup.py install --prefix="\Temp\Python"
</pre> <p>to install modules to the <code>\Temp\Python</code> directory on the current drive.</p> <p>The installation base is defined by the <code>--prefix</code> option; the <code>--exec-prefix</code> option is not supported under Windows, which means that pure Python modules and extension modules are installed into the same location. Files are installed as follows:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Installation directory</p></th> </tr> </thead>  <tr>
<td><p>modules</p></td> <td><p><code><em>prefix</em>\Lib\site-packages</code></p></td> </tr> <tr>
<td><p>scripts</p></td> <td><p><code><em>prefix</em>\Scripts</code></p></td> </tr> <tr>
<td><p>data</p></td> <td><p><code><em>prefix</em></code></p></td> </tr> <tr>
<td><p>C headers</p></td> <td><p><code><em>prefix</em>\Include{distname}</code></p></td> </tr>  </table> </section> </section> <section id="custom-installation"> <h2 id="inst-custom-install">Custom Installation</h2> <p>Sometimes, the alternate installation schemes described in section <a class="reference internal" href="#inst-alt-install"><span class="std std-ref">Alternate Installation</span></a> just don’t do what you want. You might want to tweak just one or two directories while keeping everything under the same base directory, or you might want to completely redefine the installation scheme. In either case, you’re creating a <em>custom installation scheme</em>.</p> <p>To create a custom installation scheme, you start with one of the alternate schemes and override some of the installation directories used for the various types of files, using these options:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Override option</p></th> </tr> </thead>  <tr>
<td><p>Python modules</p></td> <td><p><code>--install-purelib</code></p></td> </tr> <tr>
<td><p>extension modules</p></td> <td><p><code>--install-platlib</code></p></td> </tr> <tr>
<td><p>all modules</p></td> <td><p><code>--install-lib</code></p></td> </tr> <tr>
<td><p>scripts</p></td> <td><p><code>--install-scripts</code></p></td> </tr> <tr>
<td><p>data</p></td> <td><p><code>--install-data</code></p></td> </tr> <tr>
<td><p>C headers</p></td> <td><p><code>--install-headers</code></p></td> </tr>  </table> <p>These override options can be relative, absolute, or explicitly defined in terms of one of the installation base directories. (There are two installation base directories, and they are normally the same—they only differ when you use the Unix “prefix scheme” and supply different <code>--prefix</code> and <code>--exec-prefix</code> options; using <code>--install-lib</code> will override values computed or given for <code>--install-purelib</code> and <code>--install-platlib</code>, and is recommended for schemes that don’t make a difference between Python and extension modules.)</p> <p>For example, say you’re installing a module distribution to your home directory under Unix—but you want scripts to go in <code>~/scripts</code> rather than <code>~/bin</code>. As you might expect, you can override this directory with the <code>--install-scripts</code> option; in this case, it makes most sense to supply a relative path, which will be interpreted relative to the installation base directory (your home directory, in this case):</p> <pre data-language="none">python setup.py install --home=~ --install-scripts=scripts
</pre> <p>Another Unix example: suppose your Python installation was built and installed with a prefix of <code>/usr/local/python</code>, so under a standard installation scripts will wind up in <code>/usr/local/python/bin</code>. If you want them in <code>/usr/local/bin</code> instead, you would supply this absolute directory for the <code>--install-scripts</code> option:</p> <pre data-language="none">python setup.py install --install-scripts=/usr/local/bin
</pre> <p>(This performs an installation using the “prefix scheme”, where the prefix is whatever your Python interpreter was installed with— <code>/usr/local/python</code> in this case.)</p> <p>If you maintain Python on Windows, you might want third-party modules to live in a subdirectory of <code><em>prefix</em></code>, rather than right in <code><em>prefix</em></code> itself. This is almost as easy as customizing the script installation directory—you just have to remember that there are two types of modules to worry about, Python and extension modules, which can conveniently be both controlled by one option:</p> <pre data-language="none">python setup.py install --install-lib=Site
</pre> <p>The specified installation directory is relative to <code><em>prefix</em></code>. Of course, you also have to ensure that this directory is in Python’s module search path, such as by putting a <code>.pth</code> file in a site directory (see <a class="reference internal" href="../library/site#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a>). See section <a class="reference internal" href="#inst-search-path"><span class="std std-ref">Modifying Python’s Search Path</span></a> to find out how to modify Python’s search path.</p> <p>If you want to define an entire installation scheme, you just have to supply all of the installation directory options. The recommended way to do this is to supply relative paths; for example, if you want to maintain all Python module-related files under <code>python</code> in your home directory, and you want a separate directory for each platform that you use your home directory from, you might define the following installation scheme:</p> <pre data-language="none">python setup.py install --home=~ \
                        --install-purelib=python/lib \
                        --install-platlib=python/lib.$PLAT \
                        --install-scripts=python/scripts
                        --install-data=python/data
</pre> <p>or, equivalently,</p> <pre data-language="none">python setup.py install --home=~/python \
                        --install-purelib=lib \
                        --install-platlib='lib.$PLAT' \
                        --install-scripts=scripts
                        --install-data=data
</pre> <p><code>$PLAT</code> is not (necessarily) an environment variable—it will be expanded by the Distutils as it parses your command line options, just as it does when parsing your configuration file(s).</p> <p>Obviously, specifying the entire installation scheme every time you install a new module distribution would be very tedious. Thus, you can put these options into your Distutils config file (see section <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils Configuration Files</span></a>):</p> <pre data-language="ini">[install]
install-base=$HOME
install-purelib=python/lib
install-platlib=python/lib.$PLAT
install-scripts=python/scripts
install-data=python/data
</pre> <p>or, equivalently,</p> <pre data-language="ini">[install]
install-base=$HOME/python
install-purelib=lib
install-platlib=lib.$PLAT
install-scripts=scripts
install-data=data
</pre> <p>Note that these two are <em>not</em> equivalent if you supply a different installation base directory when you run the setup script. For example,</p> <pre data-language="none">python setup.py install --install-base=/tmp
</pre> <p>would install pure modules to <code>/tmp/python/lib</code> in the first case, and to <code>/tmp/lib</code> in the second case. (For the second case, you probably want to supply an installation base of <code>/tmp/python</code>.)</p> <p>You probably noticed the use of <code>$HOME</code> and <code>$PLAT</code> in the sample configuration file input. These are Distutils configuration variables, which bear a strong resemblance to environment variables. In fact, you can use environment variables in config files on platforms that have such a notion but the Distutils additionally define a few extra variables that may not be in your environment, such as <code>$PLAT</code>. (And of course, on systems that don’t have environment variables, such as Mac OS 9, the configuration variables supplied by the Distutils are the only ones you can use.) See section <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils Configuration Files</span></a> for details.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When a <a class="reference internal" href="../library/venv#venv-def"><span class="std std-ref">virtual environment</span></a> is activated, any options that change the installation path will be ignored from all distutils configuration files to prevent inadvertently installing projects outside of the virtual environment.</p> </div> <section id="modifying-python-s-search-path"> <h3 id="inst-search-path">Modifying Python’s Search Path</h3> <p>When the Python interpreter executes an <a class="reference internal" href="../reference/simple_stmts#import"><code>import</code></a> statement, it searches for both Python code and extension modules along a search path. A default value for the path is configured into the Python binary when the interpreter is built. You can determine the path by importing the <a class="reference internal" href="../library/sys#module-sys" title="sys: Access system-specific parameters and functions."><code>sys</code></a> module and printing the value of <code>sys.path</code>.</p> <pre data-language="none">$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/usr/local/lib/python2.3', '/usr/local/lib/python2.3/plat-linux2',
 '/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/python2.3/lib-dynload',
 '/usr/local/lib/python2.3/site-packages']
&gt;&gt;&gt;
</pre> <p>The null string in <code>sys.path</code> represents the current working directory.</p> <p>The expected convention for locally installed packages is to put them in the <code><em>…</em>/site-packages/</code> directory, but you may want to install Python modules into some arbitrary directory. For example, your site may have a convention of keeping all software related to the web server under <code>/www</code>. Add-on Python modules might then belong in <code>/www/python</code>, and in order to import them, this directory must be added to <code>sys.path</code>. There are several different ways to add the directory.</p> <p>The most convenient way is to add a path configuration file to a directory that’s already on Python’s path, usually to the <code>.../site-packages/</code> directory. Path configuration files have an extension of <code>.pth</code>, and each line must contain a single path that will be appended to <code>sys.path</code>. (Because the new paths are appended to <code>sys.path</code>, modules in the added directories will not override standard modules. This means you can’t use this mechanism for installing fixed versions of standard modules.)</p> <p>Paths can be absolute or relative, in which case they’re relative to the directory containing the <code>.pth</code> file. See the documentation of the <a class="reference internal" href="../library/site#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> module for more information.</p> <p>A slightly less convenient way is to edit the <code>site.py</code> file in Python’s standard library, and modify <code>sys.path</code>. <code>site.py</code> is automatically imported when the Python interpreter is executed, unless the <a class="reference internal" href="../using/cmdline#id3"><code>-S</code></a> switch is supplied to suppress this behaviour. So you could simply edit <code>site.py</code> and add two lines to it:</p> <pre data-language="python">import sys
sys.path.append('/www/python/')
</pre> <p>However, if you reinstall the same major version of Python (perhaps when upgrading from 2.2 to 2.2.2, for example) <code>site.py</code> will be overwritten by the stock version. You’d have to remember that it was modified and save a copy before doing the installation.</p> <p>There are two environment variables that can modify <code>sys.path</code>. <a class="reference internal" href="../using/cmdline#envvar-PYTHONHOME" id="index-0"><code>PYTHONHOME</code></a> sets an alternate value for the prefix of the Python installation. For example, if <a class="reference internal" href="../using/cmdline#envvar-PYTHONHOME" id="index-1"><code>PYTHONHOME</code></a> is set to <code>/www/python</code>, the search path will be set to <code>['', '/www/python/lib/pythonX.Y/',
'/www/python/lib/pythonX.Y/plat-linux2', ...]</code>.</p> <p>The <a class="reference internal" href="../using/cmdline#envvar-PYTHONPATH" id="index-2"><code>PYTHONPATH</code></a> variable can be set to a list of paths that will be added to the beginning of <code>sys.path</code>. For example, if <a class="reference internal" href="../using/cmdline#envvar-PYTHONPATH" id="index-3"><code>PYTHONPATH</code></a> is set to <code>/www/python:/opt/py</code>, the search path will begin with <code>['/www/python', '/opt/py']</code>. (Note that directories must exist in order to be added to <code>sys.path</code>; the <a class="reference internal" href="../library/site#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> module removes paths that don’t exist.)</p> <p>Finally, <code>sys.path</code> is just a regular Python list, so any Python application can modify it by adding or removing entries.</p> </section> </section> <section id="distutils-configuration-files"> <h2 id="inst-config-files">Distutils Configuration Files</h2> <p>As mentioned above, you can use Distutils configuration files to record personal or site preferences for any Distutils options. That is, any option to any command can be stored in one of two or three (depending on your platform) configuration files, which will be consulted before the command-line is parsed. This means that configuration files will override default values, and the command-line will in turn override configuration files. Furthermore, if multiple configuration files apply, values from “earlier” files are overridden by “later” files.</p> <section id="location-and-names-of-config-files"> <h3 id="inst-config-filenames">Location and names of config files</h3> <p>The names and locations of the configuration files vary slightly across platforms. On Unix and Mac OS X, the three configuration files (in the order they are processed) are:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Location and filename</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>system</p></td> <td><p><code><em>prefix</em>/lib/python<em>ver</em>/distutils/distutils.cfg</code></p></td> <td><p>(1)</p></td> </tr> <tr>
<td><p>personal</p></td> <td><p><code>$HOME/.pydistutils.cfg</code></p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p>local</p></td> <td><p><code>setup.cfg</code></p></td> <td><p>(3)</p></td> </tr>  </table> <p>And on Windows, the configuration files are:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Type of file</p></th> <th class="head"><p>Location and filename</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>system</p></td> <td><p><code><em>prefix</em>\Lib\distutils\distutils.cfg</code></p></td> <td><p>(4)</p></td> </tr> <tr>
<td><p>personal</p></td> <td><p><code>%HOME%\pydistutils.cfg</code></p></td> <td><p>(5)</p></td> </tr> <tr>
<td><p>local</p></td> <td><p><code>setup.cfg</code></p></td> <td><p>(3)</p></td> </tr>  </table> <p>On all platforms, the “personal” file can be temporarily disabled by passing the <code>–no-user-cfg</code> option.</p> <p>Notes:</p> <ol class="arabic simple"> <li>Strictly speaking, the system-wide configuration file lives in the directory where the Distutils are installed; under Python 1.6 and later on Unix, this is as shown. For Python 1.5.2, the Distutils will normally be installed to <code><em>prefix</em>/lib/python1.5/site-packages/distutils</code>, so the system configuration file should be put there under Python 1.5.2.</li> <li>On Unix, if the <code id="index-4">HOME</code> environment variable is not defined, the user’s home directory will be determined with the <code>getpwuid()</code> function from the standard <a class="reference internal" href="../library/pwd#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code>pwd</code></a> module. This is done by the <a class="reference internal" href="../library/os.path#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a> function used by Distutils.</li> <li>I.e., in the current directory (usually the location of the setup script).</li> <li>(See also note (1).) Under Python 1.6 and later, Python’s default “installation prefix” is <code>C:\Python</code>, so the system configuration file is normally <code>C:\Python\Lib\distutils\distutils.cfg</code>. Under Python 1.5.2, the default prefix was <code>C:\Program Files\Python</code>, and the Distutils were not part of the standard library—so the system configuration file would be <code>C:\Program Files\Python\distutils\distutils.cfg</code> in a standard Python 1.5.2 installation under Windows.</li> <li>On Windows, if the <code id="index-5">HOME</code> environment variable is not defined, <code id="index-6">USERPROFILE</code> then <code id="index-7">HOMEDRIVE</code> and <code id="index-8">HOMEPATH</code> will be tried. This is done by the <a class="reference internal" href="../library/os.path#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a> function used by Distutils.</li> </ol> </section> <section id="syntax-of-config-files"> <h3 id="inst-config-syntax">Syntax of config files</h3> <p>The Distutils configuration files all have the same syntax. The config files are grouped into sections. There is one section for each Distutils command, plus a <code>global</code> section for global options that affect every command. Each section consists of one option per line, specified as <code>option=value</code>.</p> <p>For example, the following is a complete config file that just forces all commands to run quietly by default:</p> <pre data-language="ini">[global]
verbose=0
</pre> <p>If this is installed as the system config file, it will affect all processing of any Python module distribution by any user on the current system. If it is installed as your personal config file (on systems that support them), it will affect only module distributions processed by you. And if it is used as the <code>setup.cfg</code> for a particular module distribution, it affects only that distribution.</p> <p>You could override the default “build base” directory and make the <strong class="command">build*</strong> commands always forcibly rebuild all files with the following:</p> <pre data-language="ini">[build]
build-base=blib
force=1
</pre> <p>which corresponds to the command-line arguments</p> <pre data-language="none">python setup.py build --build-base=blib --force
</pre> <p>except that including the <strong class="command">build</strong> command on the command-line means that command will be run. Including a particular command in config files has no such implication; it only means that if the command is run, the options in the config file will apply. (Or if other commands that derive values from it are run, they will use the values in the config file.)</p> <p>You can find out the complete list of options for any command using the <code>--help</code> option, e.g.:</p> <pre data-language="none">python setup.py build --help
</pre> <p>and you can find out the complete list of global options by using <code>--help</code> without a command:</p> <pre data-language="none">python setup.py --help
</pre> <p>See also the “Reference” section of the “Distributing Python Modules” manual.</p> </section> </section> <section id="building-extensions-tips-and-tricks"> <h2 id="inst-building-ext">Building Extensions: Tips and Tricks</h2> <p>Whenever possible, the Distutils try to use the configuration information made available by the Python interpreter used to run the <code>setup.py</code> script. For example, the same compiler and linker flags used to compile Python will also be used for compiling extensions. Usually this will work well, but in complicated situations this might be inappropriate. This section discusses how to override the usual Distutils behaviour.</p> <section id="tweaking-compiler-linker-flags"> <h3 id="inst-tweak-flags">Tweaking compiler/linker flags</h3> <p>Compiling a Python extension written in C or C++ will sometimes require specifying custom flags for the compiler and linker in order to use a particular library or produce a special kind of object code. This is especially true if the extension hasn’t been tested on your platform, or if you’re trying to cross-compile Python.</p> <p>In the most general case, the extension author might have foreseen that compiling the extensions would be complicated, and provided a <code>Setup</code> file for you to edit. This will likely only be done if the module distribution contains many separate extension modules, or if they often require elaborate sets of compiler flags in order to work.</p> <p>A <code>Setup</code> file, if present, is parsed in order to get a list of extensions to build. Each line in a <code>Setup</code> describes a single module. Lines have the following structure:</p> <pre data-language="none">module ... [sourcefile ...] [cpparg ...] [library ...]
</pre> <p>Let’s examine each of the fields in turn.</p> <ul class="simple"> <li>
<em>module</em> is the name of the extension module to be built, and should be a valid Python identifier. You can’t just change this in order to rename a module (edits to the source code would also be needed), so this should be left alone.</li> <li>
<em>sourcefile</em> is anything that’s likely to be a source code file, at least judging by the filename. Filenames ending in <code>.c</code> are assumed to be written in C, filenames ending in <code>.C</code>, <code>.cc</code>, and <code>.c++</code> are assumed to be C++, and filenames ending in <code>.m</code> or <code>.mm</code> are assumed to be in Objective C.</li> <li>
<em>cpparg</em> is an argument for the C preprocessor, and is anything starting with <code>-I</code>, <code>-D</code>, <code>-U</code> or <code>-C</code>.</li> <li>
<em>library</em> is anything ending in <code>.a</code> or beginning with <code>-l</code> or <code>-L</code>.</li> </ul> <p>If a particular platform requires a special library on your platform, you can add it by editing the <code>Setup</code> file and running <code>python setup.py build</code>. For example, if the module defined by the line</p> <pre data-language="none">foo foomodule.c
</pre> <p>must be linked with the math library <code>libm.a</code> on your platform, simply add <code>-lm</code> to the line:</p> <pre data-language="none">foo foomodule.c -lm
</pre> <p>Arbitrary switches intended for the compiler or the linker can be supplied with the <code>-Xcompiler</code> <em>arg</em> and <code>-Xlinker</code> <em>arg</em> options:</p> <pre data-language="none">foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm
</pre> <p>The next option after <code>-Xcompiler</code> and <code>-Xlinker</code> will be appended to the proper command line, so in the above example the compiler will be passed the <code>-o32</code> option, and the linker will be passed <code>-shared</code>. If a compiler option requires an argument, you’ll have to supply multiple <code>-Xcompiler</code> options; for example, to pass <code>-x c++</code> the <code>Setup</code> file would have to contain <code>-Xcompiler -x -Xcompiler c++</code>.</p> <p>Compiler flags can also be supplied through setting the <code id="index-9">CFLAGS</code> environment variable. If set, the contents of <code id="index-10">CFLAGS</code> will be added to the compiler flags specified in the <code>Setup</code> file.</p> </section> <section id="using-non-microsoft-compilers-on-windows"> <h3 id="inst-non-ms-compilers">Using non-Microsoft compilers on Windows</h3> <section id="borland-codegear-c"> <h4>Borland/CodeGear C++</h4> <p>This subsection describes the necessary steps to use Distutils with the Borland C++ compiler version 5.5. First you have to know that Borland’s object file format (OMF) is different from the format used by the Python version you can download from the Python or ActiveState Web site. (Python is built with Microsoft Visual C++, which uses COFF as the object file format.) For this reason you have to convert Python’s library <code>python25.lib</code> into the Borland format. You can do this as follows:</p> <pre data-language="none">coff2omf python25.lib python25_bcpp.lib
</pre> <p>The <code>coff2omf</code> program comes with the Borland compiler. The file <code>python25.lib</code> is in the <code>Libs</code> directory of your Python installation. If your extension uses other libraries (zlib, …) you have to convert them too.</p> <p>The converted files have to reside in the same directories as the normal libraries.</p> <p>How does Distutils manage to use these libraries with their changed names? If the extension needs a library (eg. <code>foo</code>) Distutils checks first if it finds a library with suffix <code>_bcpp</code> (eg. <code>foo_bcpp.lib</code>) and then uses this library. In the case it doesn’t find such a special library it uses the default name (<code>foo.lib</code>.) <a class="footnote-reference brackets" href="#id4" id="id1">1</a></p> <p>To let Distutils compile your extension with Borland C++ you now have to type:</p> <pre data-language="none">python setup.py build --compiler=bcpp
</pre> <p>If you want to use the Borland C++ compiler as the default, you could specify this in your personal or system-wide configuration file for Distutils (see section <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils Configuration Files</span></a>.)</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://www.embarcadero.com/products">C++Builder Compiler</a></dt>
<dd>
<p>Information about the free C++ compiler from Borland, including links to the download pages.</p> </dd> <dt><a class="reference external" href="http://www.cyberus.ca/~g_will/pyExtenDL.shtml">Creating Python Extensions Using Borland’s Free Compiler</a></dt>
<dd>
<p>Document describing how to use Borland’s free command-line C++ compiler to build Python.</p> </dd> </dl> </div> </section> <section id="gnu-c-cygwin-mingw"> <h4>GNU C / Cygwin / MinGW</h4> <p>This section describes the necessary steps to use Distutils with the GNU C/C++ compilers in their Cygwin and MinGW distributions. <a class="footnote-reference brackets" href="#id5" id="id2">2</a> For a Python interpreter that was built with Cygwin, everything should work without any of these following steps.</p> <p>Not all extensions can be built with MinGW or Cygwin, but many can. Extensions most likely to not work are those that use C++ or depend on Microsoft Visual C extensions.</p> <p>To let Distutils compile your extension with Cygwin you have to type:</p> <pre data-language="none">python setup.py build --compiler=cygwin
</pre> <p>and for Cygwin in no-cygwin mode <a class="footnote-reference brackets" href="#id6" id="id3">3</a> or for MinGW type:</p> <pre data-language="none">python setup.py build --compiler=mingw32
</pre> <p>If you want to use any of these options/compilers as default, you should consider writing it in your personal or system-wide configuration file for Distutils (see section <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils Configuration Files</span></a>.)</p> <section id="older-versions-of-python-and-mingw"> <h5>Older Versions of Python and MinGW</h5> <p>The following instructions only apply if you’re using a version of Python inferior to 2.4.1 with a MinGW inferior to 3.0.0 (with binutils-2.13.90-20030111-1).</p> <p>These compilers require some special libraries. This task is more complex than for Borland’s C++, because there is no program to convert the library. First you have to create a list of symbols which the Python DLL exports. (You can find a good program for this task at <a class="reference external" href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/">https://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/</a>).</p> <pre data-language="none">pexports python25.dll &gt;python25.def
</pre> <p>The location of an installed <code>python25.dll</code> will depend on the installation options and the version and language of Windows. In a “just for me” installation, it will appear in the root of the installation directory. In a shared installation, it will be located in the system directory.</p> <p>Then you can create from these information an import library for gcc.</p> <pre data-language="none">/cygwin/bin/dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a
</pre> <p>The resulting library has to be placed in the same directory as <code>python25.lib</code>. (Should be the <code>libs</code> directory under your Python installation directory.)</p> <p>If your extension uses other libraries (zlib,…) you might have to convert them too. The converted files have to reside in the same directories as the normal libraries do.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="http://old.zope.org/Members/als/tips/win32_mingw_modules">Building Python modules on MS Windows platform with MinGW</a></dt>
<dd>
<p>Information about building the required libraries for the MinGW environment.</p> </dd> </dl> </div> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id4">
<code>1</code> </dt> <dd>
<p>This also means you could replace all existing COFF-libraries with OMF-libraries of the same name.</p> </dd> <dt class="label" id="id5">
<code>2</code> </dt> <dd>
<p>Check <a class="reference external" href="https://www.sourceware.org/cygwin/">https://www.sourceware.org/cygwin/</a> for more information</p> </dd> <dt class="label" id="id6">
<code>3</code> </dt> <dd>
<p>Then you have no POSIX emulation available, but you also don’t need <code>cygwin1.dll</code>.</p> </dd> </dl> </section> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/install/index.html" class="_attribution-link">https://docs.python.org/3.8/install/index.html</a>
  </p>
</div>
