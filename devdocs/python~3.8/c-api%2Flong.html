<h1 id="longobjects">Integer Objects</h1> <p id="index-0">All integers are implemented as “long” integer objects of arbitrary size.</p> <p>On error, most <code>PyLong_As*</code> APIs return <code>(return type)-1</code> which cannot be distinguished from a number. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <dl class="type"> <dt id="c.PyLongObject">
<code>PyLongObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python integer object.</p> </dd>
</dl> <dl class="var"> <dt id="c.PyLong_Type">
<code>PyTypeObject PyLong_Type</code> </dt> <dd>
<p>This instance of <a class="reference internal" href="type#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python integer type. This is the same object as <a class="reference internal" href="../library/functions#int" title="int"><code>int</code></a> in the Python layer.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_Check">
<code>int PyLong_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if its argument is a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> or a subtype of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_CheckExact">
<code>int PyLong_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if its argument is a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, but not a subtype of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromLong">
<code>PyObject* PyLong_FromLong(long v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from <em>v</em>, or <code>NULL</code> on failure.</p> <p>The current implementation keeps an array of integer objects for all integers between <code>-5</code> and <code>256</code>, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of <code>1</code>. I suspect the behaviour of Python in this case is undefined. :-)</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromUnsignedLong">
<code>PyObject* PyLong_FromUnsignedLong(unsigned long v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <code>unsigned long</code>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromSsize_t">
<code>PyObject* PyLong_FromSsize_t(Py_ssize_t v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <code>Py_ssize_t</code>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromSize_t">
<code>PyObject* PyLong_FromSize_t(size_t v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <code>size_t</code>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromLongLong">
<code>PyObject* PyLong_FromLongLong(long long v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <code>long long</code>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromUnsignedLongLong">
<code>PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <code>unsigned long long</code>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromDouble">
<code>PyObject* PyLong_FromDouble(double v)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from the integer part of <em>v</em>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromString">
<code>PyObject* PyLong_FromString(const char *str, char **pend, int base)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> based on the string value in <em>str</em>, which is interpreted according to the radix in <em>base</em>. If <em>pend</em> is non-<code>NULL</code>, <em>*pend</em> will point to the first character in <em>str</em> which follows the representation of the number. If <em>base</em> is <code>0</code>, <em>str</em> is interpreted using the <a class="reference internal" href="../reference/lexical_analysis#integers"><span class="std std-ref">Integer literals</span></a> definition; in this case, leading zeros in a non-zero decimal number raises a <a class="reference internal" href="../library/exceptions#ValueError" title="ValueError"><code>ValueError</code></a>. If <em>base</em> is not <code>0</code>, it must be between <code>2</code> and <code>36</code>, inclusive. Leading spaces and single underscores after a base specifier and between digits are ignored. If there are no digits, <a class="reference internal" href="../library/exceptions#ValueError" title="ValueError"><code>ValueError</code></a> will be raised.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromUnicode">
<code>PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Convert a sequence of Unicode digits to a Python integer value.</p> <div class="deprecated-removed"> <p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.10: </span>Part of the old-style <a class="reference internal" href="unicode#c.Py_UNICODE" title="Py_UNICODE"><code>Py_UNICODE</code></a> API; please migrate to using <a class="reference internal" href="#c.PyLong_FromUnicodeObject" title="PyLong_FromUnicodeObject"><code>PyLong_FromUnicodeObject()</code></a>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromUnicodeObject">
<code>PyObject* PyLong_FromUnicodeObject(PyObject *u, int base)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Convert a sequence of Unicode digits in the string <em>u</em> to a Python integer value.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_FromVoidPtr">
<code>PyObject* PyLong_FromVoidPtr(void *p)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Create a Python integer from the pointer <em>p</em>. The pointer value can be retrieved from the resulting value using <a class="reference internal" href="#c.PyLong_AsVoidPtr" title="PyLong_AsVoidPtr"><code>PyLong_AsVoidPtr()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsLong">
<code>long PyLong_AsLong(PyObject *obj)</code> </dt> <dd>
<p id="index-1">Return a C <code>long</code> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> or <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>obj</em> is out of range for a <code>long</code>.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>Using <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> is deprecated.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsLongAndOverflow">
<code>long PyLong_AsLongAndOverflow(PyObject *obj, int *overflow)</code> </dt> <dd>
<p>Return a C <code>long</code> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> or <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is greater than <code>LONG_MAX</code> or less than <code>LONG_MIN</code>, set <em>*overflow</em> to <code>1</code> or <code>-1</code>, respectively, and return <code>-1</code>; otherwise, set <em>*overflow</em> to <code>0</code>. If any other exception occurs set <em>*overflow</em> to <code>0</code> and return <code>-1</code> as usual.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>Using <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> is deprecated.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsLongLong">
<code>long long PyLong_AsLongLong(PyObject *obj)</code> </dt> <dd>
<p id="index-2">Return a C <code>long long</code> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> or <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>obj</em> is out of range for a <code>long long</code>.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>Using <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> is deprecated.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsLongLongAndOverflow">
<code>long long PyLong_AsLongLongAndOverflow(PyObject *obj, int *overflow)</code> </dt> <dd>
<p>Return a C <code>long long</code> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> or <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is greater than <code>PY_LLONG_MAX</code> or less than <code>PY_LLONG_MIN</code>, set <em>*overflow</em> to <code>1</code> or <code>-1</code>, respectively, and return <code>-1</code>; otherwise, set <em>*overflow</em> to <code>0</code>. If any other exception occurs set <em>*overflow</em> to <code>0</code> and return <code>-1</code> as usual.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>Using <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> is deprecated.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsSsize_t">
<code>Py_ssize_t PyLong_AsSsize_t(PyObject *pylong)</code> </dt> <dd>
<p id="index-3">Return a C <code>Py_ssize_t</code> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <code>Py_ssize_t</code>.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsUnsignedLong">
<code>unsigned long PyLong_AsUnsignedLong(PyObject *pylong)</code> </dt> <dd>
<p id="index-4">Return a C <code>unsigned long</code> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <code>unsigned long</code>.</p> <p>Returns <code>(unsigned long)-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsSize_t">
<code>size_t PyLong_AsSize_t(PyObject *pylong)</code> </dt> <dd>
<p id="index-5">Return a C <code>size_t</code> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <code>size_t</code>.</p> <p>Returns <code>(size_t)-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsUnsignedLongLong">
<code>unsigned long long PyLong_AsUnsignedLongLong(PyObject *pylong)</code> </dt> <dd>
<p id="index-6">Return a C <code>unsigned long long</code> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for an <code>unsigned long long</code>.</p> <p>Returns <code>(unsigned long long)-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>A negative <em>pylong</em> now raises <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a>, not <a class="reference internal" href="../library/exceptions#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsUnsignedLongMask">
<code>unsigned long PyLong_AsUnsignedLongMask(PyObject *obj)</code> </dt> <dd>
<p>Return a C <code>unsigned long</code> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> or <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is out of range for an <code>unsigned long</code>, return the reduction of that value modulo <code>ULONG_MAX + 1</code>.</p> <p>Returns <code>(unsigned long)-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>Using <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> is deprecated.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsUnsignedLongLongMask">
<code>unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *obj)</code> </dt> <dd>
<p>Return a C <code>unsigned long long</code> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> or <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is out of range for an <code>unsigned long long</code>, return the reduction of that value modulo <code>PY_ULLONG_MAX + 1</code>.</p> <p>Returns <code>(unsigned long long)-1</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>Using <a class="reference internal" href="../reference/datamodel#object.__int__" title="object.__int__"><code>__int__()</code></a> is deprecated.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsDouble">
<code>double PyLong_AsDouble(PyObject *pylong)</code> </dt> <dd>
<p>Return a C <code>double</code> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <code>double</code>.</p> <p>Returns <code>-1.0</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyLong_AsVoidPtr">
<code>void* PyLong_AsVoidPtr(PyObject *pylong)</code> </dt> <dd>
<p>Convert a Python integer <em>pylong</em> to a C <code>void</code> pointer. If <em>pylong</em> cannot be converted, an <a class="reference internal" href="../library/exceptions#OverflowError" title="OverflowError"><code>OverflowError</code></a> will be raised. This is only assured to produce a usable <code>void</code> pointer for values created with <a class="reference internal" href="#c.PyLong_FromVoidPtr" title="PyLong_FromVoidPtr"><code>PyLong_FromVoidPtr()</code></a>.</p> <p>Returns <code>NULL</code> on error. Use <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/long.html" class="_attribution-link">https://docs.python.org/3.8/c-api/long.html</a>
  </p>
</div>
