<h1 id="dictobjects">Dictionary Objects</h1> <dl class="type" id="index-0"> <dt id="c.PyDictObject">
<code>PyDictObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python dictionary object.</p> </dd>
</dl> <dl class="var"> <dt id="c.PyDict_Type">
<code>PyTypeObject PyDict_Type</code> </dt> <dd>
<p>This instance of <a class="reference internal" href="type#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python dictionary type. This is the same object as <a class="reference internal" href="../library/stdtypes#dict" title="dict"><code>dict</code></a> in the Python layer.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Check">
<code>int PyDict_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a dict object or an instance of a subtype of the dict type.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_CheckExact">
<code>int PyDict_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a dict object, but not an instance of a subtype of the dict type.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_New">
<code>PyObject* PyDict_New()</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new empty dictionary, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDictProxy_New">
<code>PyObject* PyDictProxy_New(PyObject *mapping)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a <a class="reference internal" href="../library/types#types.MappingProxyType" title="types.MappingProxyType"><code>types.MappingProxyType</code></a> object for a mapping which enforces read-only behavior. This is normally used to create a view to prevent modification of the dictionary for non-dynamic class types.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Clear">
<code>void PyDict_Clear(PyObject *p)</code> </dt> <dd>
<p>Empty an existing dictionary of all key-value pairs.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Contains">
<code>int PyDict_Contains(PyObject *p, PyObject *key)</code> </dt> <dd>
<p>Determine if dictionary <em>p</em> contains <em>key</em>. If an item in <em>p</em> is matches <em>key</em>, return <code>1</code>, otherwise return <code>0</code>. On error, return <code>-1</code>. This is equivalent to the Python expression <code>key in p</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Copy">
<code>PyObject* PyDict_Copy(PyObject *p)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new dictionary that contains the same key-value pairs as <em>p</em>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_SetItem">
<code>int PyDict_SetItem(PyObject *p, PyObject *key, PyObject *val)</code> </dt> <dd>
<p>Insert <em>val</em> into the dictionary <em>p</em> with a key of <em>key</em>. <em>key</em> must be <a class="reference internal" href="../glossary#term-hashable"><span class="xref std std-term">hashable</span></a>; if it isn’t, <a class="reference internal" href="../library/exceptions#TypeError" title="TypeError"><code>TypeError</code></a> will be raised. Return <code>0</code> on success or <code>-1</code> on failure. This function <em>does not</em> steal a reference to <em>val</em>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_SetItemString">
<code>int PyDict_SetItemString(PyObject *p, const char *key, PyObject *val)</code> </dt> <dd>
<p id="index-1">Insert <em>val</em> into the dictionary <em>p</em> using <em>key</em> as a key. <em>key</em> should be a <code>const char*</code>. The key object is created using <code>PyUnicode_FromString(key)</code>. Return <code>0</code> on success or <code>-1</code> on failure. This function <em>does not</em> steal a reference to <em>val</em>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_DelItem">
<code>int PyDict_DelItem(PyObject *p, PyObject *key)</code> </dt> <dd>
<p>Remove the entry in dictionary <em>p</em> with key <em>key</em>. <em>key</em> must be hashable; if it isn’t, <a class="reference internal" href="../library/exceptions#TypeError" title="TypeError"><code>TypeError</code></a> is raised. If <em>key</em> is not in the dictionary, <a class="reference internal" href="../library/exceptions#KeyError" title="KeyError"><code>KeyError</code></a> is raised. Return <code>0</code> on success or <code>-1</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_DelItemString">
<code>int PyDict_DelItemString(PyObject *p, const char *key)</code> </dt> <dd>
<p>Remove the entry in dictionary <em>p</em> which has a key specified by the string <em>key</em>. If <em>key</em> is not in the dictionary, <a class="reference internal" href="../library/exceptions#KeyError" title="KeyError"><code>KeyError</code></a> is raised. Return <code>0</code> on success or <code>-1</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_GetItem">
<code>PyObject* PyDict_GetItem(PyObject *p, PyObject *key)</code> </dt> <dd>
<em class="refcount">Return value: Borrowed reference.</em><p>Return the object from dictionary <em>p</em> which has a key <em>key</em>. Return <code>NULL</code> if the key <em>key</em> is not present, but <em>without</em> setting an exception.</p> <p>Note that exceptions which occur while calling <a class="reference internal" href="../reference/datamodel#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> and <a class="reference internal" href="../reference/datamodel#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> methods will get suppressed. To get error reporting use <a class="reference internal" href="#c.PyDict_GetItemWithError" title="PyDict_GetItemWithError"><code>PyDict_GetItemWithError()</code></a> instead.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_GetItemWithError">
<code>PyObject* PyDict_GetItemWithError(PyObject *p, PyObject *key)</code> </dt> <dd>
<em class="refcount">Return value: Borrowed reference.</em><p>Variant of <a class="reference internal" href="#c.PyDict_GetItem" title="PyDict_GetItem"><code>PyDict_GetItem()</code></a> that does not suppress exceptions. Return <code>NULL</code> <strong>with</strong> an exception set if an exception occurred. Return <code>NULL</code> <strong>without</strong> an exception set if the key wasn’t present.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_GetItemString">
<code>PyObject* PyDict_GetItemString(PyObject *p, const char *key)</code> </dt> <dd>
<em class="refcount">Return value: Borrowed reference.</em><p>This is the same as <a class="reference internal" href="#c.PyDict_GetItem" title="PyDict_GetItem"><code>PyDict_GetItem()</code></a>, but <em>key</em> is specified as a <code>const char*</code>, rather than a <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject*</code></a>.</p> <p>Note that exceptions which occur while calling <a class="reference internal" href="../reference/datamodel#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> and <a class="reference internal" href="../reference/datamodel#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> methods and creating a temporary string object will get suppressed. To get error reporting use <a class="reference internal" href="#c.PyDict_GetItemWithError" title="PyDict_GetItemWithError"><code>PyDict_GetItemWithError()</code></a> instead.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_SetDefault">
<code>PyObject* PyDict_SetDefault(PyObject *p, PyObject *key, PyObject *defaultobj)</code> </dt> <dd>
<em class="refcount">Return value: Borrowed reference.</em><p>This is the same as the Python-level <a class="reference internal" href="../library/stdtypes#dict.setdefault" title="dict.setdefault"><code>dict.setdefault()</code></a>. If present, it returns the value corresponding to <em>key</em> from the dictionary <em>p</em>. If the key is not in the dict, it is inserted with value <em>defaultobj</em> and <em>defaultobj</em> is returned. This function evaluates the hash function of <em>key</em> only once, instead of evaluating it independently for the lookup and the insertion.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Items">
<code>PyObject* PyDict_Items(PyObject *p)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a <a class="reference internal" href="list#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> containing all the items from the dictionary.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Keys">
<code>PyObject* PyDict_Keys(PyObject *p)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a <a class="reference internal" href="list#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> containing all the keys from the dictionary.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Values">
<code>PyObject* PyDict_Values(PyObject *p)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a <a class="reference internal" href="list#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> containing all the values from the dictionary <em>p</em>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Size">
<code>Py_ssize_t PyDict_Size(PyObject *p)</code> </dt> <dd>
<p id="index-2">Return the number of items in the dictionary. This is equivalent to <code>len(p)</code> on a dictionary.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Next">
<code>int PyDict_Next(PyObject *p, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)</code> </dt> <dd>
<p>Iterate over all key-value pairs in the dictionary <em>p</em>. The <code>Py_ssize_t</code> referred to by <em>ppos</em> must be initialized to <code>0</code> prior to the first call to this function to start the iteration; the function returns true for each pair in the dictionary, and false once all pairs have been reported. The parameters <em>pkey</em> and <em>pvalue</em> should either point to <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject*</code></a> variables that will be filled in with each key and value, respectively, or may be <code>NULL</code>. Any references returned through them are borrowed. <em>ppos</em> should not be altered during iteration. Its value represents offsets within the internal dictionary structure, and since the structure is sparse, the offsets are not consecutive.</p> <p>For example:</p> <pre data-language="c">PyObject *key, *value;
Py_ssize_t pos = 0;

while (PyDict_Next(self-&gt;dict, &amp;pos, &amp;key, &amp;value)) {
    /* do something interesting with the values... */
    ...
}
</pre> <p>The dictionary <em>p</em> should not be mutated during iteration. It is safe to modify the values of the keys as you iterate over the dictionary, but only so long as the set of keys does not change. For example:</p> <pre data-language="c">PyObject *key, *value;
Py_ssize_t pos = 0;

while (PyDict_Next(self-&gt;dict, &amp;pos, &amp;key, &amp;value)) {
    long i = PyLong_AsLong(value);
    if (i == -1 &amp;&amp; PyErr_Occurred()) {
        return -1;
    }
    PyObject *o = PyLong_FromLong(i + 1);
    if (o == NULL)
        return -1;
    if (PyDict_SetItem(self-&gt;dict, key, o) &lt; 0) {
        Py_DECREF(o);
        return -1;
    }
    Py_DECREF(o);
}
</pre> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Merge">
<code>int PyDict_Merge(PyObject *a, PyObject *b, int override)</code> </dt> <dd>
<p>Iterate over mapping object <em>b</em> adding key-value pairs to dictionary <em>a</em>. <em>b</em> may be a dictionary, or any object supporting <a class="reference internal" href="mapping#c.PyMapping_Keys" title="PyMapping_Keys"><code>PyMapping_Keys()</code></a> and <a class="reference internal" href="object#c.PyObject_GetItem" title="PyObject_GetItem"><code>PyObject_GetItem()</code></a>. If <em>override</em> is true, existing pairs in <em>a</em> will be replaced if a matching key is found in <em>b</em>, otherwise pairs will only be added if there is not a matching key in <em>a</em>. Return <code>0</code> on success or <code>-1</code> if an exception was raised.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_Update">
<code>int PyDict_Update(PyObject *a, PyObject *b)</code> </dt> <dd>
<p>This is the same as <code>PyDict_Merge(a, b, 1)</code> in C, and is similar to <code>a.update(b)</code> in Python except that <a class="reference internal" href="#c.PyDict_Update" title="PyDict_Update"><code>PyDict_Update()</code></a> doesn’t fall back to the iterating over a sequence of key value pairs if the second argument has no “keys” attribute. Return <code>0</code> on success or <code>-1</code> if an exception was raised.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_MergeFromSeq2">
<code>int PyDict_MergeFromSeq2(PyObject *a, PyObject *seq2, int override)</code> </dt> <dd>
<p>Update or merge into dictionary <em>a</em>, from the key-value pairs in <em>seq2</em>. <em>seq2</em> must be an iterable object producing iterable objects of length 2, viewed as key-value pairs. In case of duplicate keys, the last wins if <em>override</em> is true, else the first wins. Return <code>0</code> on success or <code>-1</code> if an exception was raised. Equivalent Python (except for the return value):</p> <pre data-language="c">def PyDict_MergeFromSeq2(a, seq2, override):
    for key, value in seq2:
        if override or key not in a:
            a[key] = value
</pre> </dd>
</dl> <dl class="function"> <dt id="c.PyDict_ClearFreeList">
<code>int PyDict_ClearFreeList()</code> </dt> <dd>
<p>Clear the free list. Return the total number of freed items.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/dict.html" class="_attribution-link">https://docs.python.org/3.8/c-api/dict.html</a>
  </p>
</div>
