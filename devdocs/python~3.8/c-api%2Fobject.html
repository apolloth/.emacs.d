<h1 id="object">Object Protocol</h1> <dl class="var"> <dt id="c.Py_NotImplemented">
<code>PyObject* Py_NotImplemented</code> </dt> <dd>
<p>The <code>NotImplemented</code> singleton, used to signal that an operation is not implemented for the given type combination.</p> </dd>
</dl> <dl class="macro"> <dt id="c.Py_RETURN_NOTIMPLEMENTED">
<code>Py_RETURN_NOTIMPLEMENTED</code> </dt> <dd>
<p>Properly handle returning <a class="reference internal" href="#c.Py_NotImplemented" title="Py_NotImplemented"><code>Py_NotImplemented</code></a> from within a C function (that is, increment the reference count of NotImplemented and return it).</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Print">
<code>int PyObject_Print(PyObject *o, FILE *fp, int flags)</code> </dt> <dd>
<p>Print an object <em>o</em>, on file <em>fp</em>. Returns <code>-1</code> on error. The flags argument is used to enable certain printing options. The only option currently supported is <code>Py_PRINT_RAW</code>; if given, the <a class="reference internal" href="../library/stdtypes#str" title="str"><code>str()</code></a> of the object is written instead of the <a class="reference internal" href="../library/functions#repr" title="repr"><code>repr()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_HasAttr">
<code>int PyObject_HasAttr(PyObject *o, PyObject *attr_name)</code> </dt> <dd>
<p>Returns <code>1</code> if <em>o</em> has the attribute <em>attr_name</em>, and <code>0</code> otherwise. This is equivalent to the Python expression <code>hasattr(o, attr_name)</code>. This function always succeeds.</p> <p>Note that exceptions which occur while calling <a class="reference internal" href="../reference/datamodel#object.__getattr__" title="object.__getattr__"><code>__getattr__()</code></a> and <a class="reference internal" href="../reference/datamodel#object.__getattribute__" title="object.__getattribute__"><code>__getattribute__()</code></a> methods will get suppressed. To get error reporting use <a class="reference internal" href="#c.PyObject_GetAttr" title="PyObject_GetAttr"><code>PyObject_GetAttr()</code></a> instead.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_HasAttrString">
<code>int PyObject_HasAttrString(PyObject *o, const char *attr_name)</code> </dt> <dd>
<p>Returns <code>1</code> if <em>o</em> has the attribute <em>attr_name</em>, and <code>0</code> otherwise. This is equivalent to the Python expression <code>hasattr(o, attr_name)</code>. This function always succeeds.</p> <p>Note that exceptions which occur while calling <a class="reference internal" href="../reference/datamodel#object.__getattr__" title="object.__getattr__"><code>__getattr__()</code></a> and <a class="reference internal" href="../reference/datamodel#object.__getattribute__" title="object.__getattribute__"><code>__getattribute__()</code></a> methods and creating a temporary string object will get suppressed. To get error reporting use <a class="reference internal" href="#c.PyObject_GetAttrString" title="PyObject_GetAttrString"><code>PyObject_GetAttrString()</code></a> instead.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GetAttr">
<code>PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Retrieve an attribute named <em>attr_name</em> from object <em>o</em>. Returns the attribute value on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o.attr_name</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GetAttrString">
<code>PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Retrieve an attribute named <em>attr_name</em> from object <em>o</em>. Returns the attribute value on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o.attr_name</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GenericGetAttr">
<code>PyObject* PyObject_GenericGetAttr(PyObject *o, PyObject *name)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Generic attribute getter function that is meant to be put into a type object’s <code>tp_getattro</code> slot. It looks for a descriptor in the dictionary of classes in the object’s MRO as well as an attribute in the object’s <a class="reference internal" href="../library/stdtypes#object.__dict__" title="object.__dict__"><code>__dict__</code></a> (if present). As outlined in <a class="reference internal" href="../reference/datamodel#descriptors"><span class="std std-ref">Implementing Descriptors</span></a>, data descriptors take preference over instance attributes, while non-data descriptors don’t. Otherwise, an <a class="reference internal" href="../library/exceptions#AttributeError" title="AttributeError"><code>AttributeError</code></a> is raised.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_SetAttr">
<code>int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v)</code> </dt> <dd>
<p>Set the value of the attribute named <em>attr_name</em>, for object <em>o</em>, to the value <em>v</em>. Raise an exception and return <code>-1</code> on failure; return <code>0</code> on success. This is the equivalent of the Python statement <code>o.attr_name = v</code>.</p> <p>If <em>v</em> is <code>NULL</code>, the attribute is deleted, however this feature is deprecated in favour of using <a class="reference internal" href="#c.PyObject_DelAttr" title="PyObject_DelAttr"><code>PyObject_DelAttr()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_SetAttrString">
<code>int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v)</code> </dt> <dd>
<p>Set the value of the attribute named <em>attr_name</em>, for object <em>o</em>, to the value <em>v</em>. Raise an exception and return <code>-1</code> on failure; return <code>0</code> on success. This is the equivalent of the Python statement <code>o.attr_name = v</code>.</p> <p>If <em>v</em> is <code>NULL</code>, the attribute is deleted, however this feature is deprecated in favour of using <a class="reference internal" href="#c.PyObject_DelAttrString" title="PyObject_DelAttrString"><code>PyObject_DelAttrString()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GenericSetAttr">
<code>int PyObject_GenericSetAttr(PyObject *o, PyObject *name, PyObject *value)</code> </dt> <dd>
<p>Generic attribute setter and deleter function that is meant to be put into a type object’s <a class="reference internal" href="typeobj#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a> slot. It looks for a data descriptor in the dictionary of classes in the object’s MRO, and if found it takes preference over setting or deleting the attribute in the instance dictionary. Otherwise, the attribute is set or deleted in the object’s <a class="reference internal" href="../library/stdtypes#object.__dict__" title="object.__dict__"><code>__dict__</code></a> (if present). On success, <code>0</code> is returned, otherwise an <a class="reference internal" href="../library/exceptions#AttributeError" title="AttributeError"><code>AttributeError</code></a> is raised and <code>-1</code> is returned.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_DelAttr">
<code>int PyObject_DelAttr(PyObject *o, PyObject *attr_name)</code> </dt> <dd>
<p>Delete attribute named <em>attr_name</em>, for object <em>o</em>. Returns <code>-1</code> on failure. This is the equivalent of the Python statement <code>del o.attr_name</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_DelAttrString">
<code>int PyObject_DelAttrString(PyObject *o, const char *attr_name)</code> </dt> <dd>
<p>Delete attribute named <em>attr_name</em>, for object <em>o</em>. Returns <code>-1</code> on failure. This is the equivalent of the Python statement <code>del o.attr_name</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GenericGetDict">
<code>PyObject* PyObject_GenericGetDict(PyObject *o, void *context)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>A generic implementation for the getter of a <code>__dict__</code> descriptor. It creates the dictionary if necessary.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GenericSetDict">
<code>int PyObject_GenericSetDict(PyObject *o, PyObject *value, void *context)</code> </dt> <dd>
<p>A generic implementation for the setter of a <code>__dict__</code> descriptor. This implementation does not allow the dictionary to be deleted.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_RichCompare">
<code>PyObject* PyObject_RichCompare(PyObject *o1, PyObject *o2, int opid)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Compare the values of <em>o1</em> and <em>o2</em> using the operation specified by <em>opid</em>, which must be one of <code>Py_LT</code>, <code>Py_LE</code>, <code>Py_EQ</code>, <code>Py_NE</code>, <code>Py_GT</code>, or <code>Py_GE</code>, corresponding to <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>, or <code>&gt;=</code> respectively. This is the equivalent of the Python expression <code>o1 op o2</code>, where <code>op</code> is the operator corresponding to <em>opid</em>. Returns the value of the comparison on success, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_RichCompareBool">
<code>int PyObject_RichCompareBool(PyObject *o1, PyObject *o2, int opid)</code> </dt> <dd>
<p>Compare the values of <em>o1</em> and <em>o2</em> using the operation specified by <em>opid</em>, which must be one of <code>Py_LT</code>, <code>Py_LE</code>, <code>Py_EQ</code>, <code>Py_NE</code>, <code>Py_GT</code>, or <code>Py_GE</code>, corresponding to <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>, or <code>&gt;=</code> respectively. Returns <code>-1</code> on error, <code>0</code> if the result is false, <code>1</code> otherwise. This is the equivalent of the Python expression <code>o1 op o2</code>, where <code>op</code> is the operator corresponding to <em>opid</em>.</p> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If <em>o1</em> and <em>o2</em> are the same object, <a class="reference internal" href="#c.PyObject_RichCompareBool" title="PyObject_RichCompareBool"><code>PyObject_RichCompareBool()</code></a> will always return <code>1</code> for <code>Py_EQ</code> and <code>0</code> for <code>Py_NE</code>.</p> </div> <dl class="function"> <dt id="c.PyObject_Repr">
<code>PyObject* PyObject_Repr(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p id="index-0">Compute a string representation of object <em>o</em>. Returns the string representation on success, <code>NULL</code> on failure. This is the equivalent of the Python expression <code>repr(o)</code>. Called by the <a class="reference internal" href="../library/functions#repr" title="repr"><code>repr()</code></a> built-in function.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>This function now includes a debug assertion to help ensure that it does not silently discard an active exception.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_ASCII">
<code>PyObject* PyObject_ASCII(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p id="index-1">As <a class="reference internal" href="#c.PyObject_Repr" title="PyObject_Repr"><code>PyObject_Repr()</code></a>, compute a string representation of object <em>o</em>, but escape the non-ASCII characters in the string returned by <a class="reference internal" href="#c.PyObject_Repr" title="PyObject_Repr"><code>PyObject_Repr()</code></a> with <code>\x</code>, <code>\u</code> or <code>\U</code> escapes. This generates a string similar to that returned by <a class="reference internal" href="#c.PyObject_Repr" title="PyObject_Repr"><code>PyObject_Repr()</code></a> in Python 2. Called by the <a class="reference internal" href="../library/functions#ascii" title="ascii"><code>ascii()</code></a> built-in function.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Str">
<code>PyObject* PyObject_Str(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Compute a string representation of object <em>o</em>. Returns the string representation on success, <code>NULL</code> on failure. This is the equivalent of the Python expression <code>str(o)</code>. Called by the <a class="reference internal" href="../library/stdtypes#str" title="str"><code>str()</code></a> built-in function and, therefore, by the <a class="reference internal" href="../library/functions#print" title="print"><code>print()</code></a> function.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>This function now includes a debug assertion to help ensure that it does not silently discard an active exception.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Bytes">
<code>PyObject* PyObject_Bytes(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p id="index-3">Compute a bytes representation of object <em>o</em>. <code>NULL</code> is returned on failure and a bytes object on success. This is equivalent to the Python expression <code>bytes(o)</code>, when <em>o</em> is not an integer. Unlike <code>bytes(o)</code>, a TypeError is raised when <em>o</em> is an integer instead of a zero-initialized bytes object.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_IsSubclass">
<code>int PyObject_IsSubclass(PyObject *derived, PyObject *cls)</code> </dt> <dd>
<p>Return <code>1</code> if the class <em>derived</em> is identical to or derived from the class <em>cls</em>, otherwise return <code>0</code>. In case of an error, return <code>-1</code>.</p> <p>If <em>cls</em> is a tuple, the check will be done against every entry in <em>cls</em>. The result will be <code>1</code> when at least one of the checks returns <code>1</code>, otherwise it will be <code>0</code>.</p> <p>If <em>cls</em> has a <a class="reference internal" href="../reference/datamodel#class.__subclasscheck__" title="class.__subclasscheck__"><code>__subclasscheck__()</code></a> method, it will be called to determine the subclass status as described in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119" id="index-4"><strong>PEP 3119</strong></a>. Otherwise, <em>derived</em> is a subclass of <em>cls</em> if it is a direct or indirect subclass, i.e. contained in <code>cls.__mro__</code>.</p> <p>Normally only class objects, i.e. instances of <a class="reference internal" href="../library/functions#type" title="type"><code>type</code></a> or a derived class, are considered classes. However, objects can override this by having a <code>__bases__</code> attribute (which must be a tuple of base classes).</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_IsInstance">
<code>int PyObject_IsInstance(PyObject *inst, PyObject *cls)</code> </dt> <dd>
<p>Return <code>1</code> if <em>inst</em> is an instance of the class <em>cls</em> or a subclass of <em>cls</em>, or <code>0</code> if not. On error, returns <code>-1</code> and sets an exception.</p> <p>If <em>cls</em> is a tuple, the check will be done against every entry in <em>cls</em>. The result will be <code>1</code> when at least one of the checks returns <code>1</code>, otherwise it will be <code>0</code>.</p> <p>If <em>cls</em> has a <a class="reference internal" href="../reference/datamodel#class.__instancecheck__" title="class.__instancecheck__"><code>__instancecheck__()</code></a> method, it will be called to determine the subclass status as described in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119" id="index-5"><strong>PEP 3119</strong></a>. Otherwise, <em>inst</em> is an instance of <em>cls</em> if its class is a subclass of <em>cls</em>.</p> <p>An instance <em>inst</em> can override what is considered its class by having a <code>__class__</code> attribute.</p> <p>An object <em>cls</em> can override if it is considered a class, and what its base classes are, by having a <code>__bases__</code> attribute (which must be a tuple of base classes).</p> </dd>
</dl> <dl class="function"> <dt id="c.PyCallable_Check">
<code>int PyCallable_Check(PyObject *o)</code> </dt> <dd>
<p>Determine if the object <em>o</em> is callable. Return <code>1</code> if the object is callable and <code>0</code> otherwise. This function always succeeds.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Call">
<code>PyObject* PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the tuple <em>args</em>, and named arguments given by the dictionary <em>kwargs</em>.</p> <p><em>args</em> must not be <code>NULL</code>, use an empty tuple if no arguments are needed. If no named arguments are needed, <em>kwargs</em> can be <code>NULL</code>.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(*args, **kwargs)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_CallObject">
<code>PyObject* PyObject_CallObject(PyObject *callable, PyObject *args)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the tuple <em>args</em>. If no arguments are needed, then <em>args</em> can be <code>NULL</code>.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(*args)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_CallFunction">
<code>PyObject* PyObject_CallFunction(PyObject *callable, const char *format, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with a variable number of C arguments. The C arguments are described using a <a class="reference internal" href="arg#c.Py_BuildValue" title="Py_BuildValue"><code>Py_BuildValue()</code></a> style format string. The format can be <code>NULL</code>, indicating that no arguments are provided.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(*args)</code>.</p> <p>Note that if you only pass <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject *</code></a> args, <a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code>PyObject_CallFunctionObjArgs()</code></a> is a faster alternative.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The type of <em>format</em> was changed from <code>char *</code>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_CallMethod">
<code>PyObject* PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Call the method named <em>name</em> of object <em>obj</em> with a variable number of C arguments. The C arguments are described by a <a class="reference internal" href="arg#c.Py_BuildValue" title="Py_BuildValue"><code>Py_BuildValue()</code></a> format string that should produce a tuple.</p> <p>The format can be <code>NULL</code>, indicating that no arguments are provided.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> <p>This is the equivalent of the Python expression: <code>obj.name(arg1, arg2, ...)</code>.</p> <p>Note that if you only pass <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject *</code></a> args, <a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code>PyObject_CallMethodObjArgs()</code></a> is a faster alternative.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The types of <em>name</em> and <em>format</em> were changed from <code>char *</code>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_CallFunctionObjArgs">
<code>PyObject* PyObject_CallFunctionObjArgs(PyObject *callable, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with a variable number of <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject*</code></a> arguments. The arguments are provided as a variable number of parameters followed by <code>NULL</code>.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(arg1, arg2, ...)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_CallMethodObjArgs">
<code>PyObject* PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Calls a method of the Python object <em>obj</em>, where the name of the method is given as a Python string object in <em>name</em>. It is called with a variable number of <a class="reference internal" href="structures#c.PyObject" title="PyObject"><code>PyObject*</code></a> arguments. The arguments are provided as a variable number of parameters followed by <code>NULL</code>.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="function"> <dt id="c._PyObject_Vectorcall">
<code>PyObject* _PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)</code> </dt> <dd>
<p>Call a callable Python object <em>callable</em>, using <a class="reference internal" href="typeobj#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>vectorcall</code></a> if possible.</p> <p><em>args</em> is a C array with the positional arguments.</p> <p><em>nargsf</em> is the number of positional arguments plus optionally the flag <code>PY_VECTORCALL_ARGUMENTS_OFFSET</code> (see below). To get actual number of arguments, use <a class="reference internal" href="#c.PyVectorcall_NARGS" title="PyVectorcall_NARGS"><code>PyVectorcall_NARGS(nargsf)</code></a>.</p> <p><em>kwnames</em> can be either <code>NULL</code> (no keyword arguments) or a tuple of keyword names. In the latter case, the values of the keyword arguments are stored in <em>args</em> after the positional arguments. The number of keyword arguments does not influence <em>nargsf</em>.</p> <p><em>kwnames</em> must contain only objects of type <code>str</code> (not a subclass), and all keys must be unique.</p> <p>Return the result of the call on success, or raise an exception and return <code>NULL</code> on failure.</p> <p>This uses the vectorcall protocol if the callable supports it; otherwise, the arguments are converted to use <a class="reference internal" href="typeobj#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is provisional and expected to become public in Python 3.9, with a different name and, possibly, changed semantics. If you use the function, plan for updating your code for Python 3.9.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="macro"> <dt id="c.PY_VECTORCALL_ARGUMENTS_OFFSET">
<code>PY_VECTORCALL_ARGUMENTS_OFFSET</code> </dt> <dd>
<p>If set in a vectorcall <em>nargsf</em> argument, the callee is allowed to temporarily change <code>args[-1]</code>. In other words, <em>args</em> points to argument 1 (not 0) in the allocated vector. The callee must restore the value of <code>args[-1]</code> before returning.</p> <p>Whenever they can do so cheaply (without additional allocation), callers are encouraged to use <code>PY_VECTORCALL_ARGUMENTS_OFFSET</code>. Doing so will allow callables such as bound methods to make their onward calls (which include a prepended <em>self</em> argument) cheaply.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyVectorcall_NARGS">
<code>Py_ssize_t PyVectorcall_NARGS(size_t nargsf)</code> </dt> <dd>
<p>Given a vectorcall <em>nargsf</em> argument, return the actual number of arguments. Currently equivalent to <code>nargsf &amp; ~PY_VECTORCALL_ARGUMENTS_OFFSET</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c._PyObject_FastCallDict">
<code>PyObject* _PyObject_FastCallDict(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwdict)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#c._PyObject_Vectorcall" title="_PyObject_Vectorcall"><code>_PyObject_Vectorcall()</code></a> except that the keyword arguments are passed as a dictionary in <em>kwdict</em>. This may be <code>NULL</code> if there are no keyword arguments.</p> <p>For callables supporting <a class="reference internal" href="typeobj#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>vectorcall</code></a>, the arguments are internally converted to the vectorcall convention. Therefore, this function adds some overhead compared to <a class="reference internal" href="#c._PyObject_Vectorcall" title="_PyObject_Vectorcall"><code>_PyObject_Vectorcall()</code></a>. It should only be used if the caller already has a dictionary ready to use.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is provisional and expected to become public in Python 3.9, with a different name and, possibly, changed semantics. If you use the function, plan for updating your code for Python 3.9.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Hash">
<code>Py_hash_t PyObject_Hash(PyObject *o)</code> </dt> <dd>
<p id="index-6">Compute and return the hash value of an object <em>o</em>. On failure, return <code>-1</code>. This is the equivalent of the Python expression <code>hash(o)</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The return type is now Py_hash_t. This is a signed integer the same size as Py_ssize_t.</p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_HashNotImplemented">
<code>Py_hash_t PyObject_HashNotImplemented(PyObject *o)</code> </dt> <dd>
<p>Set a <a class="reference internal" href="../library/exceptions#TypeError" title="TypeError"><code>TypeError</code></a> indicating that <code>type(o)</code> is not hashable and return <code>-1</code>. This function receives special treatment when stored in a <code>tp_hash</code> slot, allowing a type to explicitly indicate to the interpreter that it is not hashable.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_IsTrue">
<code>int PyObject_IsTrue(PyObject *o)</code> </dt> <dd>
<p>Returns <code>1</code> if the object <em>o</em> is considered to be true, and <code>0</code> otherwise. This is equivalent to the Python expression <code>not not o</code>. On failure, return <code>-1</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Not">
<code>int PyObject_Not(PyObject *o)</code> </dt> <dd>
<p>Returns <code>0</code> if the object <em>o</em> is considered to be true, and <code>1</code> otherwise. This is equivalent to the Python expression <code>not o</code>. On failure, return <code>-1</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Type">
<code>PyObject* PyObject_Type(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p id="index-7">When <em>o</em> is non-<code>NULL</code>, returns a type object corresponding to the object type of object <em>o</em>. On failure, raises <a class="reference internal" href="../library/exceptions#SystemError" title="SystemError"><code>SystemError</code></a> and returns <code>NULL</code>. This is equivalent to the Python expression <code>type(o)</code>. This function increments the reference count of the return value. There’s really no reason to use this function instead of the common expression <code>o-&gt;ob_type</code>, which returns a pointer of type <a class="reference internal" href="type#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject*</code></a>, except when the incremented reference count is needed.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_TypeCheck">
<code>int PyObject_TypeCheck(PyObject *o, PyTypeObject *type)</code> </dt> <dd>
<p>Return true if the object <em>o</em> is of type <em>type</em> or a subtype of <em>type</em>. Both parameters must be non-<code>NULL</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Size">
<code>Py_ssize_t PyObject_Size(PyObject *o)</code> </dt> <dt id="c.PyObject_Length">
<code>Py_ssize_t PyObject_Length(PyObject *o)</code> </dt> <dd>
<p id="index-8">Return the length of object <em>o</em>. If the object <em>o</em> provides either the sequence and mapping protocols, the sequence length is returned. On error, <code>-1</code> is returned. This is the equivalent to the Python expression <code>len(o)</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_LengthHint">
<code>Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t default)</code> </dt> <dd>
<p>Return an estimated length for the object <em>o</em>. First try to return its actual length, then an estimate using <a class="reference internal" href="../reference/datamodel#object.__length_hint__" title="object.__length_hint__"><code>__length_hint__()</code></a>, and finally return the default value. On error return <code>-1</code>. This is the equivalent to the Python expression <code>operator.length_hint(o, default)</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GetItem">
<code>PyObject* PyObject_GetItem(PyObject *o, PyObject *key)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return element of <em>o</em> corresponding to the object <em>key</em> or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o[key]</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_SetItem">
<code>int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)</code> </dt> <dd>
<p>Map the object <em>key</em> to the value <em>v</em>. Raise an exception and return <code>-1</code> on failure; return <code>0</code> on success. This is the equivalent of the Python statement <code>o[key] = v</code>. This function <em>does not</em> steal a reference to <em>v</em>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_DelItem">
<code>int PyObject_DelItem(PyObject *o, PyObject *key)</code> </dt> <dd>
<p>Remove the mapping for the object <em>key</em> from the object <em>o</em>. Return <code>-1</code> on failure. This is equivalent to the Python statement <code>del o[key]</code>.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_Dir">
<code>PyObject* PyObject_Dir(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>This is equivalent to the Python expression <code>dir(o)</code>, returning a (possibly empty) list of strings appropriate for the object argument, or <code>NULL</code> if there was an error. If the argument is <code>NULL</code>, this is like the Python <code>dir()</code>, returning the names of the current locals; in this case, if no execution frame is active then <code>NULL</code> is returned but <a class="reference internal" href="exceptions#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> will return false.</p> </dd>
</dl> <dl class="function"> <dt id="c.PyObject_GetIter">
<code>PyObject* PyObject_GetIter(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>This is equivalent to the Python expression <code>iter(o)</code>. It returns a new iterator for the object argument, or the object itself if the object is already an iterator. Raises <a class="reference internal" href="../library/exceptions#TypeError" title="TypeError"><code>TypeError</code></a> and returns <code>NULL</code> if the object cannot be iterated.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/object.html" class="_attribution-link">https://docs.python.org/3.8/c-api/object.html</a>
  </p>
</div>
