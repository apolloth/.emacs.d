<h1 id="common-structs">Common Object Structures</h1> <p>There are a large number of structures which are used in the definition of object types for Python. This section describes these structures and how they are used.</p> <p>All Python objects ultimately share a small number of fields at the beginning of the object’s representation in memory. These are represented by the <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> and <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects.</p> <dl class="type"> <dt id="c.PyObject">
<code>PyObject</code> </dt> <dd>
<p>All object types are extensions of this type. This is a type which contains the information Python needs to treat a pointer to an object as an object. In a normal “release” build, it contains only the object’s reference count and a pointer to the corresponding type object. Nothing is actually declared to be a <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a>, but every pointer to a Python object can be cast to a <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a>. Access to the members must be done by using the macros <a class="reference internal" href="#c.Py_REFCNT" title="Py_REFCNT"><code>Py_REFCNT</code></a> and <a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE</code></a>.</p> </dd>
</dl> <dl class="type"> <dt id="c.PyVarObject">
<code>PyVarObject</code> </dt> <dd>
<p>This is an extension of <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> that adds the <code>ob_size</code> field. This is only used for objects that have some notion of <em>length</em>. This type does not often appear in the Python/C API. Access to the members must be done by using the macros <a class="reference internal" href="#c.Py_REFCNT" title="Py_REFCNT"><code>Py_REFCNT</code></a>, <a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE</code></a>, and <a class="reference internal" href="#c.Py_SIZE" title="Py_SIZE"><code>Py_SIZE</code></a>.</p> </dd>
</dl> <dl class="macro"> <dt id="c.PyObject_HEAD">
<code>PyObject_HEAD</code> </dt> <dd>
<p>This is a macro used when declaring new types which represent objects without a varying length. The PyObject_HEAD macro expands to:</p> <pre data-language="c">PyObject ob_base;
</pre> <p>See documentation of <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> above.</p> </dd>
</dl> <dl class="macro"> <dt id="c.PyObject_VAR_HEAD">
<code>PyObject_VAR_HEAD</code> </dt> <dd>
<p>This is a macro used when declaring new types which represent objects with a length that varies from instance to instance. The PyObject_VAR_HEAD macro expands to:</p> <pre data-language="c">PyVarObject ob_base;
</pre> <p>See documentation of <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> above.</p> </dd>
</dl> <dl class="macro"> <dt id="c.Py_TYPE">
<code>Py_TYPE(o)</code> </dt> <dd>
<p>This macro is used to access the <code>ob_type</code> member of a Python object. It expands to:</p> <pre data-language="c">(((PyObject*)(o))-&gt;ob_type)
</pre> </dd>
</dl> <dl class="macro"> <dt id="c.Py_REFCNT">
<code>Py_REFCNT(o)</code> </dt> <dd>
<p>This macro is used to access the <code>ob_refcnt</code> member of a Python object. It expands to:</p> <pre data-language="c">(((PyObject*)(o))-&gt;ob_refcnt)
</pre> </dd>
</dl> <dl class="macro"> <dt id="c.Py_SIZE">
<code>Py_SIZE(o)</code> </dt> <dd>
<p>This macro is used to access the <code>ob_size</code> member of a Python object. It expands to:</p> <pre data-language="c">(((PyVarObject*)(o))-&gt;ob_size)
</pre> </dd>
</dl> <dl class="macro"> <dt id="c.PyObject_HEAD_INIT">
<code>PyObject_HEAD_INIT(type)</code> </dt> <dd>
<p>This is a macro which expands to initialization values for a new <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> type. This macro expands to:</p> <pre data-language="c">_PyObject_EXTRA_INIT
1, type,
</pre> </dd>
</dl> <dl class="macro"> <dt id="c.PyVarObject_HEAD_INIT">
<code>PyVarObject_HEAD_INIT(type, size)</code> </dt> <dd>
<p>This is a macro which expands to initialization values for a new <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> type, including the <code>ob_size</code> field. This macro expands to:</p> <pre data-language="c">_PyObject_EXTRA_INIT
1, type, size,
</pre> </dd>
</dl> <dl class="type"> <dt id="c.PyCFunction">
<code>PyCFunction</code> </dt> <dd>
<p>Type of the functions used to implement most Python callables in C. Functions of this type take two <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> parameters and return one such value. If the return value is <code>NULL</code>, an exception shall have been set. If not <code>NULL</code>, the return value is interpreted as the return value of the function as exposed in Python. The function must return a new reference.</p> </dd>
</dl> <dl class="type"> <dt id="c.PyCFunctionWithKeywords">
<code>PyCFunctionWithKeywords</code> </dt> <dd>
<p>Type of the functions used to implement Python callables in C with signature <code>METH_VARARGS | METH_KEYWORDS</code>.</p> </dd>
</dl> <dl class="type"> <dt id="c._PyCFunctionFast">
<code>_PyCFunctionFast</code> </dt> <dd>
<p>Type of the functions used to implement Python callables in C with signature <a class="reference internal" href="#METH_FASTCALL" title="METH_FASTCALL"><code>METH_FASTCALL</code></a>.</p> </dd>
</dl> <dl class="type"> <dt id="c._PyCFunctionFastWithKeywords">
<code>_PyCFunctionFastWithKeywords</code> </dt> <dd>
<p>Type of the functions used to implement Python callables in C with signature <code>METH_FASTCALL | METH_KEYWORDS</code>.</p> </dd>
</dl> <dl class="type"> <dt id="c.PyMethodDef">
<code>PyMethodDef</code> </dt> <dd>
<p>Structure used to describe a method of an extension type. This structure has four fields:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Field</p></th> <th class="head"><p>C Type</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>ml_name</code></p></td> <td><p>const char *</p></td> <td><p>name of the method</p></td> </tr> <tr>
<td><p><code>ml_meth</code></p></td> <td><p>PyCFunction</p></td> <td><p>pointer to the C implementation</p></td> </tr> <tr>
<td><p><code>ml_flags</code></p></td> <td><p>int</p></td> <td><p>flag bits indicating how the call should be constructed</p></td> </tr> <tr>
<td><p><code>ml_doc</code></p></td> <td><p>const char *</p></td> <td><p>points to the contents of the docstring</p></td> </tr>  </table> </dd>
</dl> <p>The <code>ml_meth</code> is a C function pointer. The functions may be of different types, but they always return <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a>. If the function is not of the <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>, the compiler will require a cast in the method table. Even though <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a> defines the first parameter as <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a>, it is common that the method implementation uses the specific C type of the <em>self</em> object.</p> <p>The <code>ml_flags</code> field is a bitfield which can include the following flags. The individual flags indicate either a calling convention or a binding convention.</p> <p>There are four basic calling conventions for positional arguments and two of them can be combined with <code>METH_KEYWORDS</code> to support also keyword arguments. So there are a total of 6 calling conventions:</p> <dl class="data"> <dt id="METH_VARARGS">
<code>METH_VARARGS</code> </dt> <dd>
<p>This is the typical calling convention, where the methods have the type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>. The function expects two <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> values. The first one is the <em>self</em> object for methods; for module functions, it is the module object. The second parameter (often called <em>args</em>) is a tuple object representing all arguments. This parameter is typically processed using <a class="reference internal" href="arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> or <a class="reference internal" href="arg#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code>PyArg_UnpackTuple()</code></a>.</p> </dd>
</dl> <dl class="data"> <dt>
<code>METH_VARARGS | METH_KEYWORDS</code> </dt> <dd>
<p>Methods with these flags must be of type <a class="reference internal" href="#c.PyCFunctionWithKeywords" title="PyCFunctionWithKeywords"><code>PyCFunctionWithKeywords</code></a>. The function expects three parameters: <em>self</em>, <em>args</em>, <em>kwargs</em> where <em>kwargs</em> is a dictionary of all the keyword arguments or possibly <code>NULL</code> if there are no keyword arguments. The parameters are typically processed using <a class="reference internal" href="arg#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a>.</p> </dd>
</dl> <dl class="data"> <dt id="METH_FASTCALL">
<code>METH_FASTCALL</code> </dt> <dd>
<p>Fast calling convention supporting only positional arguments. The methods have the type <a class="reference internal" href="#c._PyCFunctionFast" title="_PyCFunctionFast"><code>_PyCFunctionFast</code></a>. The first parameter is <em>self</em>, the second parameter is a C array of <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> values indicating the arguments and the third parameter is the number of arguments (the length of the array).</p> <p>This is not part of the <a class="reference internal" href="stable#stable"><span class="std std-ref">limited API</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7.</span></p> </div> </dd>
</dl> <dl class="data"> <dt>
<code>METH_FASTCALL | METH_KEYWORDS</code> </dt> <dd>
<p>Extension of <a class="reference internal" href="#METH_FASTCALL" title="METH_FASTCALL"><code>METH_FASTCALL</code></a> supporting also keyword arguments, with methods of type <a class="reference internal" href="#c._PyCFunctionFastWithKeywords" title="_PyCFunctionFastWithKeywords"><code>_PyCFunctionFastWithKeywords</code></a>. Keyword arguments are passed the same way as in the vectorcall protocol: there is an additional fourth <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> parameter which is a tuple representing the names of the keyword arguments or possibly <code>NULL</code> if there are no keywords. The values of the keyword arguments are stored in the <em>args</em> array, after the positional arguments.</p> <p>This is not part of the <a class="reference internal" href="stable#stable"><span class="std std-ref">limited API</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7.</span></p> </div> </dd>
</dl> <dl class="data"> <dt id="METH_NOARGS">
<code>METH_NOARGS</code> </dt> <dd>
<p>Methods without parameters don’t need to check whether arguments are given if they are listed with the <a class="reference internal" href="#METH_NOARGS" title="METH_NOARGS"><code>METH_NOARGS</code></a> flag. They need to be of type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>. The first parameter is typically named <em>self</em> and will hold a reference to the module or object instance. In all cases the second parameter will be <code>NULL</code>.</p> </dd>
</dl> <dl class="data"> <dt id="METH_O">
<code>METH_O</code> </dt> <dd>
<p>Methods with a single object argument can be listed with the <a class="reference internal" href="#METH_O" title="METH_O"><code>METH_O</code></a> flag, instead of invoking <a class="reference internal" href="arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> with a <code>"O"</code> argument. They have the type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>, with the <em>self</em> parameter, and a <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> parameter representing the single argument.</p> </dd>
</dl> <p>These two constants are not used to indicate the calling convention but the binding when use with methods of classes. These may not be used for functions defined for modules. At most one of these flags may be set for any given method.</p> <dl class="data"> <dt id="METH_CLASS">
<code>METH_CLASS</code> </dt> <dd>
<p id="index-0">The method will be passed the type object as the first parameter rather than an instance of the type. This is used to create <em>class methods</em>, similar to what is created when using the <a class="reference internal" href="../library/functions#classmethod" title="classmethod"><code>classmethod()</code></a> built-in function.</p> </dd>
</dl> <dl class="data"> <dt id="METH_STATIC">
<code>METH_STATIC</code> </dt> <dd>
<p id="index-1">The method will be passed <code>NULL</code> as the first parameter rather than an instance of the type. This is used to create <em>static methods</em>, similar to what is created when using the <a class="reference internal" href="../library/functions#staticmethod" title="staticmethod"><code>staticmethod()</code></a> built-in function.</p> </dd>
</dl> <p>One other constant controls whether a method is loaded in place of another definition with the same method name.</p> <dl class="data"> <dt id="METH_COEXIST">
<code>METH_COEXIST</code> </dt> <dd>
<p>The method will be loaded in place of existing definitions. Without <em>METH_COEXIST</em>, the default is to skip repeated definitions. Since slot wrappers are loaded before the method table, the existence of a <em>sq_contains</em> slot, for example, would generate a wrapped method named <a class="reference internal" href="../reference/datamodel#object.__contains__" title="object.__contains__"><code>__contains__()</code></a> and preclude the loading of a corresponding PyCFunction with the same name. With the flag defined, the PyCFunction will be loaded in place of the wrapper object and will co-exist with the slot. This is helpful because calls to PyCFunctions are optimized more than wrapper object calls.</p> </dd>
</dl> <dl class="type"> <dt id="c.PyMemberDef">
<code>PyMemberDef</code> </dt> <dd>
<p>Structure which describes an attribute of a type which corresponds to a C struct member. Its fields are:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Field</p></th> <th class="head"><p>C Type</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>name</code></p></td> <td><p>const char *</p></td> <td><p>name of the member</p></td> </tr> <tr>
<td><p><code>type</code></p></td> <td><p>int</p></td> <td><p>the type of the member in the C struct</p></td> </tr> <tr>
<td><p><code>offset</code></p></td> <td><p>Py_ssize_t</p></td> <td><p>the offset in bytes that the member is located on the type’s object struct</p></td> </tr> <tr>
<td><p><code>flags</code></p></td> <td><p>int</p></td> <td><p>flag bits indicating if the field should be read-only or writable</p></td> </tr> <tr>
<td><p><code>doc</code></p></td> <td><p>const char *</p></td> <td><p>points to the contents of the docstring</p></td> </tr>  </table> <p><code>type</code> can be one of many <code>T_</code> macros corresponding to various C types. When the member is accessed in Python, it will be converted to the equivalent Python type.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Macro name</p></th> <th class="head"><p>C type</p></th> </tr> </thead>  <tr>
<td><p>T_SHORT</p></td> <td><p>short</p></td> </tr> <tr>
<td><p>T_INT</p></td> <td><p>int</p></td> </tr> <tr>
<td><p>T_LONG</p></td> <td><p>long</p></td> </tr> <tr>
<td><p>T_FLOAT</p></td> <td><p>float</p></td> </tr> <tr>
<td><p>T_DOUBLE</p></td> <td><p>double</p></td> </tr> <tr>
<td><p>T_STRING</p></td> <td><p>const char *</p></td> </tr> <tr>
<td><p>T_OBJECT</p></td> <td><p>PyObject *</p></td> </tr> <tr>
<td><p>T_OBJECT_EX</p></td> <td><p>PyObject *</p></td> </tr> <tr>
<td><p>T_CHAR</p></td> <td><p>char</p></td> </tr> <tr>
<td><p>T_BYTE</p></td> <td><p>char</p></td> </tr> <tr>
<td><p>T_UBYTE</p></td> <td><p>unsigned char</p></td> </tr> <tr>
<td><p>T_UINT</p></td> <td><p>unsigned int</p></td> </tr> <tr>
<td><p>T_USHORT</p></td> <td><p>unsigned short</p></td> </tr> <tr>
<td><p>T_ULONG</p></td> <td><p>unsigned long</p></td> </tr> <tr>
<td><p>T_BOOL</p></td> <td><p>char</p></td> </tr> <tr>
<td><p>T_LONGLONG</p></td> <td><p>long long</p></td> </tr> <tr>
<td><p>T_ULONGLONG</p></td> <td><p>unsigned long long</p></td> </tr> <tr>
<td><p>T_PYSSIZET</p></td> <td><p>Py_ssize_t</p></td> </tr>  </table> <p><code>T_OBJECT</code> and <code>T_OBJECT_EX</code> differ in that <code>T_OBJECT</code> returns <code>None</code> if the member is <code>NULL</code> and <code>T_OBJECT_EX</code> raises an <a class="reference internal" href="../library/exceptions#AttributeError" title="AttributeError"><code>AttributeError</code></a>. Try to use <code>T_OBJECT_EX</code> over <code>T_OBJECT</code> because <code>T_OBJECT_EX</code> handles use of the <a class="reference internal" href="../reference/simple_stmts#del"><code>del</code></a> statement on that attribute more correctly than <code>T_OBJECT</code>.</p> <p><code>flags</code> can be <code>0</code> for write and read access or <code>READONLY</code> for read-only access. Using <code>T_STRING</code> for <a class="reference internal" href="../library/functions#type" title="type"><code>type</code></a> implies <code>READONLY</code>. <code>T_STRING</code> data is interpreted as UTF-8. Only <code>T_OBJECT</code> and <code>T_OBJECT_EX</code> members can be deleted. (They are set to <code>NULL</code>).</p> </dd>
</dl> <dl class="type"> <dt id="c.PyGetSetDef">
<code>PyGetSetDef</code> </dt> <dd>
<p>Structure to define property-like access for a type. See also description of the <a class="reference internal" href="typeobj#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code>PyTypeObject.tp_getset</code></a> slot.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Field</p></th> <th class="head"><p>C Type</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p>name</p></td> <td><p>const char *</p></td> <td><p>attribute name</p></td> </tr> <tr>
<td><p>get</p></td> <td><p>getter</p></td> <td><p>C Function to get the attribute</p></td> </tr> <tr>
<td><p>set</p></td> <td><p>setter</p></td> <td><p>optional C function to set or delete the attribute, if omitted the attribute is readonly</p></td> </tr> <tr>
<td><p>doc</p></td> <td><p>const char *</p></td> <td><p>optional docstring</p></td> </tr> <tr>
<td><p>closure</p></td> <td><p>void *</p></td> <td><p>optional function pointer, providing additional data for getter and setter</p></td> </tr>  </table> <p>The <code>get</code> function takes one <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> parameter (the instance) and a function pointer (the associated <code>closure</code>):</p> <pre data-language="c">typedef PyObject *(*getter)(PyObject *, void *);
</pre> <p>It should return a new reference on success or <code>NULL</code> with a set exception on failure.</p> <p><code>set</code> functions take two <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject*</code></a> parameters (the instance and the value to be set) and a function pointer (the associated <code>closure</code>):</p> <pre data-language="c">typedef int (*setter)(PyObject *, PyObject *, void *);
</pre> <p>In case the attribute should be deleted the second parameter is <code>NULL</code>. Should return <code>0</code> on success or <code>-1</code> with a set exception on failure.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.8/c-api/structures.html" class="_attribution-link">https://docs.python.org/3.8/c-api/structures.html</a>
  </p>
</div>
